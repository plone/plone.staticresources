{"version":3,"file":"chunks/15244.7b7825cc058f9d81fa1b.min.js","mappings":";2NAOA,MAAMA,EAAMC,EAAAA,EAAAA,UAAkB,gBACxBC,EAAuB,QAEvBC,EAAWC,EAAAA,EAAAA,OAAY,CACzBC,KAAM,WACNC,QAAS,gBAETC,aACI,GAAIC,KAAKC,IAAIC,GAAGF,KAAKF,SAAU,CAK3B,MAAMK,EAASH,KAAKC,IAAIC,GAAG,UACrBF,KAAKC,IAAIG,MACTJ,KAAKC,IAAI,GAAGI,UAClB,IAAIC,QAAiBN,KAAKO,OAAOJ,GACjCH,KAAKQ,GAAGH,UAAY,GACpBL,KAAKQ,GAAGC,UAAUH,EAAS,GAAGI,WACjC,CACJ,EAEDX,aAAaY,GACT,MAAMC,SAAgB,uCAAkBA,OAClCC,SAAmB,uCAAqBC,QACxCC,SAAyB,kCAAgDD,QAEzEE,EAAUC,SAASC,cAAc,OACjCC,EAASN,EAAUO,SAASR,EAAOS,MAAMV,IAC/CK,EAAQX,UAAYc,EACpB,IAAK,MAAMG,KAAQN,EAAQO,iBAAiB,cAAe,CACvD,MAAMC,EAAMF,EAAKG,cACjBD,EAAIE,UAAUC,IAAI,wBAIlB,IAAIZ,EAAgBS,SACdI,EAAAA,EAAAA,YAAmBJ,EAAK,iCACjC,CACD,OAAOK,IAAEb,EACZ,EAEDjB,yBAAyB+B,EAAKC,GAC1B,IAAIC,EACA7B,EAAS4B,EACb,GAAID,EAAI3B,QAAuD,QAA5C6B,EAAS,aAAaC,KAAKH,EAAI3B,SAAmB,CAEjE,GADAA,EAASH,KAAKkC,eAAe/B,EAAQ6B,EAAO,IAC7B,OAAX7B,EAEA,OADAX,EAAI2C,KAAK,2BAA6BL,EAAI3B,OAAS,QAAU2B,EAAIM,KAC1DP,IAAE,UAAUQ,KAAK,WAAYP,EAAIM,KAE5CjC,GAAU,IACb,CAED,aADuBH,KAAKO,OAAOJ,IACnBkC,KAAK,WAAYP,EAAI3B,OAAS2B,EAAIM,IAAMN,EAAI3B,OAAS2B,EAAIM,IAC5E,EAEDF,eAAevB,EAAMqB,GACjB,IAAIM,EACJN,EAASO,EAAAA,EAAAA,aAAmBP,GAC5B,IAAIQ,EAAU,IAAIC,OACd,kDAAkDC,QAAQ,UAAWV,GACrE,KAEAW,EAAQH,EAAQP,KAAKtB,GACzB,GAAc,OAAVgC,EACA,OAAO,KACJ,GAAIA,EAAM,GAAI,CAEjB,MAAMC,EAAQD,EAAM,GAAGE,OACvBP,EACI,+EACJA,EAAUA,EAAQI,QAAQ,WAAYE,EACzC,KAAM,KAAID,EAAM,GAUb,OADAnD,EAAIsD,MAAM,kCAAmCH,GACtC,KAPHL,EADa,MAAbK,EAAM,GAEF,qEAGA,uEAIX,CAOD,OANAL,EAAUA,EAAQI,QAAQ,UAAWV,GACrCQ,EAAU,IAAIC,OAAOH,EAAS,KAC9BK,EAAQH,EAAQP,KAAKtB,GACP,OAAVgC,GACAnD,EAAIsD,MAAM,qDAEG,OAAVH,EAAiBA,EAAM,GAAK,IACtC,IAGLd,IAAEZ,UAAU8B,OAAM,WACdlB,IAAEZ,SAAS+B,MAAMC,GACb,yCACA,gBACA,WAIiBpB,IAAE7B,MAAM+B,KAAK,cACrBmB,SAAQ,SAAUpB,GACfpC,EAAqByD,KAAKrB,EAAIM,OAC9BN,EAAIsB,SAAW,WAEtB,GACJ,GAER,IAEDC,EAAAA,EAAAA,oBAA2B,WAAY,CACnCtD,cAAcuD,EAAMvB,GAChB,aAAawB,QAAQC,IACjBF,EAAKG,KAAI1D,eAAgB+B,GACrB,MAAM4B,EAAM,IAAI/D,EAASmC,EAAI6B,QAAQ,IAErC,aADuBD,EAAIE,mBAAmB9B,EAAKC,EAEtD,IAER,IAGL,W","sources":["webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["import $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport events from \"../../core/events\";\nimport inject from \"../inject/inject\";\n\nconst log = logging.getLogger(\"pat.markdown\");\nconst is_markdown_resource = /\\.md$/;\n\nconst Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            const source = this.$el.is(\":input\")\n                ? this.$el.val()\n                : this.$el[0].innerHTML;\n            let rendered = await this.render(source);\n            this.el.innerHTML = \"\";\n            this.el.append(...rendered[0].childNodes);\n        }\n    },\n\n    async render(text) {\n        const marked = (await import(\"marked\")).marked;\n        const DOMPurify = (await import(\"dompurify\")).default;\n        const SyntaxHighlight = (await import(\"../syntax-highlight/syntax-highlight\")).default; // prettier-ignore\n\n        const wrapper = document.createElement(\"div\");\n        const parsed = DOMPurify.sanitize(marked.parse(text));\n        wrapper.innerHTML = parsed;\n        for (const item of wrapper.querySelectorAll(\"pre > code\")) {\n            const pre = item.parentElement;\n            pre.classList.add(\"pat-syntax-highlight\");\n            // If the code block language was set in a fenced code block,\n            // marked has already set the language as a class on the code tag.\n            // pat-syntax-highlight will understand this.\n            new SyntaxHighlight(pre);\n            await events.await_event(pre, \"init.syntax-highlight.patterns\");\n        }\n        return $(wrapper);\n    },\n\n    async renderForInjection(cfg, data) {\n        let header;\n        let source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        let pattern;\n        header = utils.escapeRegExp(header);\n        let matcher = new RegExp(\n            \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(/@TEXT@/g, header),\n            \"m\"\n        );\n        let match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            const level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            const cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                const pat = new Markdown(cfg.$target[0]);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["log","logging","is_markdown_resource","Markdown","Base","name","trigger","async","this","$el","is","source","val","innerHTML","rendered","render","el","append","childNodes","text","marked","DOMPurify","default","SyntaxHighlight","wrapper","document","createElement","parsed","sanitize","parse","item","querySelectorAll","pre","parentElement","classList","add","events","$","cfg","data","header","exec","extractSection","warn","url","attr","pattern","utils","matcher","RegExp","replace","match","level","length","error","ready","body","on","forEach","test","dataType","inject","cfgs","Promise","all","map","pat","$target","renderForInjection"],"sourceRoot":""}