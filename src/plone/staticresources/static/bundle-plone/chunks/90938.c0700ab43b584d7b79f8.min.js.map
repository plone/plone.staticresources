{"version":3,"file":"chunks/90938.c0700ab43b584d7b79f8.min.js","mappings":"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","sources":["webpack://plone.staticresources/./node_modules/mockup/node_modules/@patternslib/patternslib/src/core/jquery-ext.js","webpack://plone.staticresources/./node_modules/mockup/node_modules/@patternslib/patternslib/src/pat/ajax/ajax.js","webpack://plone.staticresources/./node_modules/mockup/node_modules/@patternslib/patternslib/src/pat/inject/inject.js","webpack://plone.staticresources/./node_modules/mockup/node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["/**\n * @license\n * Patterns @VERSION@ jquery-ext - various jQuery extensions\n *\n * Copyright 2011 Humberto Sermeño\n */\n\nimport $ from \"jquery\";\n\nvar methods = {\n    init: function (options) {\n        var settings = {\n            time: 3 /* time it will wait before moving to \"timeout\" after a move event */,\n            initialTime: 8 /* time it will wait before first adding the \"timeout\" class */,\n            exceptionAreas: [] /* IDs of elements that, if the mouse is over them, will reset the timer */,\n        };\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            if (!data) {\n                if (options) {\n                    $.extend(settings, options);\n                }\n                $this.data(\"timeout\", {\n                    lastEvent: new Date(),\n                    trueTime: settings.time,\n                    time: settings.initialTime,\n                    untouched: true,\n                    inExceptionArea: false,\n                });\n\n                $this.on(\"mouseover.timeout\", methods.mouseMoved);\n                $this.on(\"mouseenter.timeout\", methods.mouseMoved);\n\n                $(settings.exceptionAreas).each(function () {\n                    $this\n                        .find(this)\n                        .live(\n                            \"mouseover.timeout\",\n                            { parent: $this },\n                            methods.enteredException\n                        )\n                        .live(\n                            \"mouseleave.timeout\",\n                            { parent: $this },\n                            methods.leftException\n                        );\n                });\n\n                if (settings.initialTime > 0) $this.timeout(\"startTimer\");\n                else $this.addClass(\"timeout\");\n            }\n        });\n    },\n\n    enteredException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = true;\n        event.data.parent.data(\"timeout\", data);\n        event.data.parent.trigger(\"mouseover\");\n    },\n\n    leftException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = false;\n        event.data.parent.data(\"timeout\", data);\n    },\n\n    destroy: function () {\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            $(window).off(\".timeout\");\n            data.timeout.remove();\n            $this.removeData(\"timeout\");\n        });\n    },\n\n    mouseMoved: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n\n        if ($this.hasClass(\"timeout\")) {\n            $this.removeClass(\"timeout\");\n            $this.timeout(\"startTimer\");\n        } else if (data.untouched) {\n            data.untouched = false;\n            data.time = data.trueTime;\n        }\n\n        data.lastEvent = new Date();\n        $this.data(\"timeout\", data);\n    },\n\n    startTimer: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n        var fn = function () {\n            var data = $this.data(\"timeout\");\n            if (data && data.lastEvent) {\n                if (data.inExceptionArea) {\n                    setTimeout(fn, Math.floor(data.time * 1000));\n                } else {\n                    var now = new Date();\n                    var diff = Math.floor(data.time * 1000) - (now - data.lastEvent);\n                    if (diff > 0) {\n                        // the timeout has not ocurred, so set the timeout again\n                        setTimeout(fn, diff + 100);\n                    } else {\n                        // timeout ocurred, so set the class\n                        $this.addClass(\"timeout\");\n                    }\n                }\n            }\n        };\n\n        setTimeout(fn, Math.floor(data.time * 1000));\n    },\n};\n\n$.fn.timeout = function (method) {\n    if (methods[method]) {\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof method === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n    } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timeout\");\n    }\n};\n\n// Custom jQuery selector to find elements with scrollbars\n$.extend($.expr[\":\"], {\n    scrollable: function (element) {\n        var vertically_scrollable, horizontally_scrollable;\n        if (\n            $(element).css(\"overflow\") === \"scroll\" ||\n            $(element).css(\"overflowX\") === \"scroll\" ||\n            $(element).css(\"overflowY\") === \"scroll\"\n        )\n            return true;\n\n        vertically_scrollable =\n            element.clientHeight < element.scrollHeight &&\n            ($.inArray($(element).css(\"overflowY\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n\n        if (vertically_scrollable) return true;\n\n        horizontally_scrollable =\n            element.clientWidth < element.scrollWidth &&\n            ($.inArray($(element).css(\"overflowX\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n        return horizontally_scrollable;\n    },\n});\n\n// Make Visible in scroll\n$.fn.makeVisibleInScroll = function (parent_id) {\n    var absoluteParent = null;\n    if (typeof parent_id === \"string\") {\n        absoluteParent = $(\"#\" + parent_id);\n    } else if (parent_id) {\n        absoluteParent = $(parent_id);\n    }\n\n    return this.each(function () {\n        var $this = $(this),\n            parent;\n        if (!absoluteParent) {\n            parent = $this.parents(\":scrollable\");\n            if (parent.length > 0) {\n                parent = $(parent[0]);\n            } else {\n                parent = $(window);\n            }\n        } else {\n            parent = absoluteParent;\n        }\n\n        var elemTop = $this.position().top;\n        var elemBottom = $this.height() + elemTop;\n\n        var viewTop = parent.scrollTop();\n        var viewBottom = parent.height() + viewTop;\n\n        if (elemTop < viewTop) {\n            parent.scrollTop(elemTop);\n        } else if (elemBottom > viewBottom - parent.height() / 2) {\n            parent.scrollTop(elemTop - (parent.height() - $this.height()) / 2);\n        }\n    });\n};\n\n//Work around warning for jQuery 3.x:\n//JQMIGRATE: jQuery.fn.offset() requires an element connected to a document\n$.fn.safeOffset = function () {\n    var docElem,\n        elem = this[0],\n        origin = { top: 0, left: 0 };\n\n    if (!elem || !elem.nodeType) {\n        return origin;\n    }\n\n    docElem = (elem.ownerDocument || document).documentElement;\n    if (!$.contains(docElem, elem)) {\n        return origin;\n    }\n\n    return $.fn.offset.apply(this, arguments);\n};\n\n//Make absolute location\n$.fn.setPositionAbsolute = function (element, offsettop, offsetleft) {\n    return this.each(function () {\n        // set absolute location for based on the element passed\n        // dynamically since every browser has different settings\n        var $this = $(this);\n        var thiswidth = $(this).width();\n        var pos = element.safeOffset();\n        var width = element.width();\n        var height = element.height();\n        var setleft = pos.left + width - thiswidth + offsetleft;\n        var settop = pos.top + height + offsettop;\n        $this.css({\n            \"z-index\": 1,\n            \"position\": \"absolute\",\n            \"marginLeft\": 0,\n            \"marginTop\": 0,\n            \"left\": setleft + \"px\",\n            \"top\": settop + \"px\",\n            \"width\": thiswidth,\n        });\n        $this.remove().appendTo(\"body\").show();\n    });\n};\n\n$.fn.positionAncestor = function (selector) {\n    var left = 0;\n    var top = 0;\n    this.each(function () {\n        // check if current element has an ancestor matching a selector\n        // and that ancestor is positioned\n        var $ancestor = $(this).closest(selector);\n        if ($ancestor.length && $ancestor.css(\"position\") !== \"static\") {\n            var $child = $(this);\n            var childMarginEdgeLeft =\n                $child.safeOffset().left - parseInt($child.css(\"marginLeft\"), 10);\n            var childMarginEdgeTop =\n                $child.safeOffset().top - parseInt($child.css(\"marginTop\"), 10);\n            var ancestorPaddingEdgeLeft =\n                $ancestor.safeOffset().left +\n                parseInt($ancestor.css(\"borderLeftWidth\"), 10);\n            var ancestorPaddingEdgeTop =\n                $ancestor.safeOffset().top +\n                parseInt($ancestor.css(\"borderTopWidth\"), 10);\n            left = childMarginEdgeLeft - ancestorPaddingEdgeLeft;\n            top = childMarginEdgeTop - ancestorPaddingEdgeTop;\n            // we have found the ancestor and computed the position\n            // stop iterating\n            return false;\n        }\n    });\n    return {\n        left: left,\n        top: top,\n    };\n};\n\n$.fn.findInclusive = function (selector) {\n    return this.find(\"*\").addBack().filter(selector);\n};\n\n$.fn.slideIn = function (speed, easing, callback) {\n    return this.animate({ width: \"show\" }, speed, easing, callback);\n};\n\n$.fn.slideOut = function (speed, easing, callback) {\n    return this.animate({ width: \"hide\" }, speed, easing, callback);\n};\n\n// case-insensitive :contains\n$.expr[\":\"].Contains = function (a, i, m) {\n    return $(a).text().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;\n};\n\n$.fn.scopedFind = function (selector) {\n    /*  If the selector starts with an object id do a global search,\n     *  otherwise do a local search.\n     */\n    if (selector.indexOf(\"#\") === 0) {\n        return $(selector);\n    } else {\n        return this.find(selector);\n    }\n};\n\nexport default undefined;\n","/**\n * Patterns ajax - AJAX injection for forms and anchors\n *\n * Copyright 2012-2013 Florian Friesdorf\n * Copyright 2012-2013 Marko Durkovic\n */\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\n\nconst log = logging.getLogger(\"pat.ajax\");\n\nexport const parser = new Parser(\"ajax\");\nparser.addArgument(\"accept\", \"text/html\");\nparser.addArgument(\"url\", function ($el) {\n    return (\n        $el.is(\"a\") ? $el.attr(\"href\") : $el.is(\"form\") ? $el.attr(\"action\") : \"\"\n    ).split(\"#\")[0];\n});\n\n$.ajaxSetup({\n    // Disable caching of AJAX responses\n    cache: false,\n});\n\nconst xhrCount = {};\nxhrCount.get = function (a) {\n    return this[a] !== undefined ? this[a] : 0;\n};\nxhrCount.inc = function (a) {\n    this[a] = this.get(a) + 1;\n    return this.get(a);\n};\n\nconst _ = {\n    name: \"ajax\",\n    trigger: \".pat-ajax\",\n    parser: parser,\n    init($el) {\n        $el.off(\".pat-ajax\");\n        $el.filter(\"a\").on(\"click.pat-ajax\", _.onTriggerEvents);\n        $el.filter(\"form\")\n            .on(\"submit.pat-ajax\", _.onTriggerEvents)\n            .on(\"click.pat-ajax\", \"[type=submit]\", _.onClickSubmit);\n        $el.filter(\":not(form,a)\").each(function () {\n            log.warn(\"Unsupported element:\", this);\n        });\n        return $el;\n    },\n    destroy($el) {\n        $el.off(\".pat-ajax\");\n    },\n    onClickSubmit(event) {\n        const el = event.target;\n        const form = el.closest(\"form\");\n        const data = {};\n        if (el.name) {\n            data[el.name] = el.value;\n        }\n        $(form).data(\"pat-ajax.clicked-data\", data);\n    },\n    onTriggerEvents(event) {\n        if (event) {\n            event.preventDefault();\n        }\n        _.request($(this));\n    },\n    request($el, opts) {\n        return $el.each(function () {\n            _._request($(this), opts);\n        });\n    },\n    _request($el, opts) {\n        const cfg = _.parser.parse($el, opts);\n        const onError = function (jqxhr, status, error) {\n            // error can also stem from a javascript\n            // exception, not only errors described in the\n            // jqxhr.\n            log.error(\"load error for \" + cfg.url + \":\", error, jqxhr);\n            $el.trigger({\n                type: \"pat-ajax-error\",\n                jqxhr: jqxhr,\n            });\n        };\n        const seqNumber = xhrCount.inc(cfg.url);\n        const onSuccess = function (data, status, jqxhr) {\n            log.debug(\"success: jqxhr:\", jqxhr);\n            if (seqNumber === xhrCount.get(cfg.url)) {\n                // if this url is requested multiple time, only return the last result\n                $el.trigger({\n                    type: \"pat-ajax-success\",\n                    jqxhr: jqxhr,\n                });\n            } else {\n                // ignore\n            }\n        };\n        const temp = $el.data(\"pat-ajax.clicked-data\");\n        const clickedData = temp ? $.param(temp) : \"\";\n        const args = {\n            context: $el,\n            data: [$el.serialize(), clickedData].filter(Boolean).join(\"&\"),\n            headers: {},\n            url: cfg.url,\n            method: $el.attr(\"method\") ? $el.attr(\"method\") : \"GET\",\n        };\n\n        if (cfg.accept) {\n            args.headers.Accept = cfg.accept;\n        }\n\n        if (\n            $el.is(\"form\") &&\n            $el.attr(\"method\") &&\n            $el.attr(\"method\").toUpperCase() == \"POST\"\n        ) {\n            const formdata = new FormData($el[0]);\n            for (const key in temp) {\n                formdata.append(key, temp[key]);\n            }\n            args[\"method\"] = \"POST\";\n            args[\"data\"] = formdata;\n            args[\"cache\"] = false;\n            args[\"contentType\"] = false;\n            args[\"processData\"] = false;\n            args[\"type\"] = \"POST\";\n        }\n\n        $el.removeData(\"pat-ajax.clicked-data\");\n        log.debug(\"request:\", args, $el[0]);\n\n        // Make it happen\n        const ajax_deferred = $.ajax(args);\n\n        if (ajax_deferred) ajax_deferred.done(onSuccess).fail(onError);\n    },\n};\n\nregistry.register(_);\n\nexport default _;\n","import \"../../core/jquery-ext\"; // for :scrollable for autoLoading-visible\nimport \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport _ from \"underscore\";\nimport ajax from \"../ajax/ajax\";\nimport dom from \"../../core/dom\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.inject\");\n//log.setLevel(logging.Level.DEBUG);\n\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\n\nexport const parser = new Parser(\"inject\");\nparser.addArgument(\"default-selector\");\nparser.addArgument(\"target\");\nparser.addArgument(\"data-type\", \"html\");\nparser.addArgument(\"next-href\");\nparser.addArgument(\"source\");\nparser.addArgument(\"trigger\", \"default\", [\n    \"default\",\n    \"autoload\",\n    \"autoload-visible\",\n    \"idle\",\n]);\nparser.addArgument(\"delay\"); // only used in autoload\nparser.addArgument(\"confirm\", \"class\", [\"never\", \"always\", \"form-data\", \"class\"]);\nparser.addArgument(\"confirm-message\", \"Are you sure you want to leave this page?\");\nparser.addArgument(\"hooks\", [], [\"raptor\"], true); // After injection, pat-inject will trigger an event for each hook: pat-inject-hook-$(hook)\nparser.addArgument(\"loading-class\", \"injecting\"); // Add a class to the target while content is still loading.\nparser.addArgument(\"executing-class\", \"executing\"); // Add a class to the element while content is still loading.\nparser.addArgument(\"executed-class\", \"executed\"); // Add a class to the element when content is loaded.\nparser.addArgument(\"class\"); // Add a class to the injected content.\nparser.addArgument(\"history\");\nparser.addArgument(\"push-marker\");\nparser.addArgument(\"scroll\");\n// XXX: this should not be here but the parser would bail on\n// unknown parameters and expand/collapsible need to pass the url\n// to us\nparser.addArgument(\"url\");\n\nconst inject = {\n    name: \"inject\",\n    trigger:\n        \".raptor-ui .ui-button.pat-inject, a.pat-inject, form.pat-inject, .pat-subform.pat-inject\",\n    parser: parser,\n\n    init($el, opts) {\n        const cfgs = this.extractConfig($el, opts);\n        if (cfgs.some((e) => e.history === \"record\") && !(\"pushState\" in history)) {\n            // if the injection shall add a history entry and HTML5 pushState\n            // is missing, then don't initialize the injection.\n            return $el;\n        }\n        $el.data(\"pat-inject\", cfgs);\n\n        if (cfgs[0].nextHref && cfgs[0].nextHref.indexOf(\"#\") === 0) {\n            // In case the next href is an anchor, and it already\n            // exists in the page, we do not activate the injection\n            // but instead just change the anchors href.\n\n            // XXX: This is used in only one project for linked\n            // fullcalendars, it's sanity is wonky and we should\n            // probably solve it differently.\n            if ($el.is(\"a\") && $(cfgs[0].nextHref).length > 0) {\n                log.debug(\n                    \"Skipping as next href is anchor, which already exists\",\n                    cfgs[0].nextHref\n                );\n                // XXX: reconsider how the injection enters exhausted state\n                return $el.attr({\n                    href: (window.location.href.split(\"#\")[0] || \"\") + cfgs[0].nextHref,\n                });\n            }\n        }\n        if (cfgs[0].pushMarker) {\n            $(\"body\").on(\"push\", (event, data) => {\n                log.debug(\"received push message: \" + data);\n                if (data == cfgs[0].pushMarker) {\n                    log.debug(\"re-injecting \" + data);\n                    this.onTrigger({ currentTarget: $el[0] });\n                }\n            });\n        }\n        if (cfgs[0].idleTrigger) {\n            this._initIdleTrigger($el, cfgs[0].idleTrigger);\n        } else {\n            switch (cfgs[0].trigger) {\n                case \"default\":\n                    cfgs.forEach((cfg) => {\n                        if (cfg.delay) {\n                            cfg.processDelay = cfg.delay;\n                        }\n                    });\n                    // setup event handlers\n                    if ($el.is(\"form\")) {\n                        $el.on(\"submit.pat-inject\", this.onTrigger.bind(this))\n                            .on(\"click.pat-inject\", \"[type=submit]\", ajax.onClickSubmit)\n                            .on(\n                                \"click.pat-inject\",\n                                \"[type=submit][formaction], [type=image][formaction]\",\n                                this.onFormActionSubmit.bind(this)\n                            );\n                    } else if ($el.is(\".pat-subform\")) {\n                        log.debug(\"Initializing subform with injection\");\n                    } else {\n                        $el.on(\"click.pat-inject\", this.onTrigger.bind(this));\n                    }\n                    break;\n                case \"autoload\":\n                    if (!cfgs[0].delay) {\n                        this.onTrigger({ currentTarget: $el[0] });\n                    } else {\n                        // generate UID\n                        const uid = Math.random().toString(36);\n                        $el.attr(\"data-pat-inject-uid\", uid);\n\n                        // function to trigger the autoload and mark as triggered\n                        const delayed_trigger = (uid_) => {\n                            // Check if the element has been removed from the dom\n                            const still_there = $(\n                                \"[data-pat-inject-uid='\" + uid_ + \"']\"\n                            );\n                            if (still_there.length == 0) return false;\n\n                            $el.data(\"pat-inject-autoloaded\", true);\n                            this.onTrigger({ currentTarget: $el[0] });\n                            return true;\n                        };\n                        window.setTimeout(\n                            delayed_trigger.bind(null, uid),\n                            cfgs[0].delay\n                        );\n                    }\n                    break;\n                case \"autoload-visible\":\n                    this._initAutoloadVisible($el, cfgs);\n                    break;\n                case \"idle\":\n                    this._initIdleTrigger($el, cfgs[0].delay);\n                    break;\n            }\n        }\n\n        log.debug(\"initialised:\", $el);\n        return $el;\n    },\n\n    destroy($el) {\n        $el.off(\".pat-inject\");\n        $el.data(\"pat-inject\", null);\n        return $el;\n    },\n\n    onTrigger(e) {\n        /* Injection has been triggered, either via form submission or a\n         * link has been clicked.\n         */\n        const $el = $(e.currentTarget);\n        const cfgs = $el.data(\"pat-inject\");\n        if ($el.is(\"form\")) {\n            $(cfgs).each((i, v) => {\n                v.params = $.param($el.serializeArray());\n            });\n        }\n        e.preventDefault && e.preventDefault();\n        $el.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $el);\n    },\n\n    onFormActionSubmit(e) {\n        ajax.onClickSubmit(e); // make sure the submitting button is sent with the form\n\n        const $button = $(e.target);\n        const formaction = $button.attr(\"formaction\");\n        const $form = $button.parents(\".pat-inject\").first();\n        const opts = {\n            url: formaction,\n        };\n        const $cfg_node = $button.closest(\"[data-pat-inject]\");\n        const cfgs = this.extractConfig($cfg_node, opts);\n\n        $(cfgs).each((i, v) => {\n            v.params = $.param($form.serializeArray());\n        });\n\n        e.preventDefault();\n        $form.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $form);\n    },\n\n    submitSubform($sub) {\n        /* This method is called from pat-subform\n         */\n        const $el = $sub.parents(\"form\");\n        const cfgs = $sub.data(\"pat-inject\");\n\n        // store the params of the subform in the config, to be used by history\n        $(cfgs).each((i, v) => {\n            v.params = $.param($sub.serializeArray());\n        });\n\n        try {\n            $el.trigger(\"patterns-inject-triggered\");\n        } catch (e) {\n            log.error(\"patterns-inject-triggered\", e);\n        }\n        this.execute(cfgs, $el);\n    },\n\n    extractConfig($el, opts) {\n        opts = $.extend({}, opts);\n\n        const cfgs = parser.parse($el, opts, true);\n        cfgs.forEach((cfg) => {\n            cfg.$context = $el;\n            // opts and cfg have priority, fall back to href/action\n            cfg.url =\n                opts.url ||\n                cfg.url ||\n                $el.attr(\"href\") ||\n                $el.attr(\"action\") ||\n                $el.parents(\"form\").attr(\"action\") ||\n                \"\";\n\n            // separate selector from url\n            const urlparts = cfg.url.split(\"#\");\n            cfg.url = urlparts[0];\n\n            if (urlparts.length > 2) {\n                log.warn(\"Ignoring additional source ids:\", urlparts.slice(2));\n            }\n\n            if (!cfg.defaultSelector) {\n                // if no selector, check for selector as part of original url\n                cfg.defaultSelector = (urlparts[1] && \"#\" + urlparts[1]) || \"body\";\n            }\n            if (cfg.delay) {\n                try {\n                    cfg.delay = utils.parseTime(cfg.delay);\n                } catch (e) {\n                    log.warn(\"Invalid delay value: \", cfg.delay);\n                    cfg.delay = null;\n                }\n            }\n            cfg.processDelay = 0;\n        });\n        return cfgs;\n    },\n\n    elementIsDirty(m) {\n        /* Check whether the passed in form element contains a value.\n         */\n        const data = $.map(m.find(\":input:not(select)\"), (i) => {\n            const val = $(i).val();\n            return Boolean(val) && val !== $(i).attr(\"placeholder\");\n        });\n        return $.inArray(true, data) !== -1;\n    },\n\n    askForConfirmation(cfgs) {\n        /* If configured to do so, show a confirmation dialog to the user.\n         * This is done before attempting to perform injection.\n         */\n        let should_confirm = false;\n        let message;\n\n        _.each(cfgs, (cfg) => {\n            let _confirm = false;\n            if (cfg.confirm == \"always\") {\n                _confirm = true;\n            } else if (cfg.confirm === \"form-data\") {\n                if (cfg.target != \"none\") _confirm = this.elementIsDirty(cfg.$target);\n            } else if (cfg.confirm === \"class\") {\n                if (cfg.target != \"none\") _confirm = cfg.$target.hasClass(\"is-dirty\");\n            }\n            if (_confirm) {\n                should_confirm = true;\n                message = cfg.confirmMessage;\n            }\n        });\n        if (should_confirm) {\n            if (!window.confirm(message)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    ensureTarget(cfg) {\n        /* Make sure that a target element exists and that it's assigned to\n         * cfg.$target.\n         */\n        // make sure target exist\n        if (cfg.target === \"none\") {\n            // special case, we don't want to inject anything\n            return true;\n        }\n        cfg.$target =\n            cfg.$target || (cfg.target === \"self\" ? cfg.$context : $(cfg.target));\n        if (cfg.$target.length === 0) {\n            if (!cfg.target) {\n                log.error(\"Need target selector\", cfg);\n                return false;\n            }\n            cfg.$target = this.createTarget(cfg.target);\n            cfg.$injected = cfg.$target;\n        }\n        return true;\n    },\n\n    verifySingleConfig(url, cfg) {\n        /* Verify one of potentially multiple configs (i.e. argument lists).\n         *\n         * Extract modifiers such as ::element or ::after.\n         * Ensure that a target element exists.\n         */\n        if (cfg.url !== url) {\n            // in case of multi-injection, all injections need to use\n            // the same url\n            log.error(\"Unsupported different urls for multi-inject\");\n            return false;\n        }\n        // defaults\n        cfg.source = cfg.source || cfg.defaultSelector;\n        cfg.target = cfg.target || cfg.defaultSelector;\n\n        if (!this.extractModifiers(cfg)) {\n            return false;\n        }\n        if (!this.ensureTarget(cfg)) {\n            return false;\n        }\n        this.listenForFormReset(cfg);\n        return true;\n    },\n\n    verifyConfig(cfgs) {\n        /* Verify and post-process all the configurations.\n         * Each \"config\" is an arguments list separated by the &&\n         * combination operator.\n         *\n         * In case of multi-injection, only one URL is allowed, which\n         * should be specified in the first config (i.e. arguments list).\n         *\n         * Verification for each cfg in the array needs to succeed.\n         */\n        return cfgs.every(_.partial(this.verifySingleConfig.bind(this), cfgs[0].url));\n    },\n\n    listenForFormReset(cfg) {\n        /* if pat-inject is used to populate target in some form and when\n         * Cancel button is pressed (this triggers reset event on the\n         * form) you would expect to populate with initial placeholder\n         */\n        if (cfg.target === \"none\")\n            // Special case, we don't want to display any return value.\n            return;\n        const $form = cfg.$target.parents(\"form\");\n        if ($form.length !== 0 && cfg.$target.data(\"initial-value\") === undefined) {\n            cfg.$target.data(\"initial-value\", cfg.$target.html());\n            $form.on(\"reset\", () => {\n                cfg.$target.html(cfg.$target.data(\"initial-value\"));\n            });\n        }\n    },\n\n    extractModifiers(cfg) {\n        /* The user can add modifiers to the source and target arguments.\n         * Modifiers such as ::element, ::before and ::after.\n         * We identifiy and extract these modifiers here.\n         */\n        const source_re = /^(.*?)(::element)?$/;\n        const target_re = /^(.*?)(::element)?(::after|::before)?$/;\n        const source_match = source_re.exec(cfg.source);\n        const target_match = target_re.exec(cfg.target);\n\n        cfg.source = source_match[1];\n        cfg.sourceMod = source_match[2] ? \"element\" : \"content\";\n        cfg.target = target_match[1];\n        const targetMod = target_match[2] ? \"element\" : \"content\";\n        const targetPosition = (target_match[3] || \"::\").slice(2); // position relative to target\n\n        if (cfg.loadingClass) {\n            cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetMod;\n            if (targetPosition && cfg.loadingClass) {\n                cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetPosition;\n            }\n        }\n        cfg.action = targetMod + targetPosition;\n        // Once we start detecting illegal combinations, we'll\n        // return false in case of error\n        return true;\n    },\n\n    createTarget(selector) {\n        /* create a target that matches the selector\n         *\n         * XXX: so far we only support #target and create a div with\n         * that id appended to the body.\n         */\n        if (selector.slice(0, 1) !== \"#\") {\n            log.error(\"only id supported for non-existing target\");\n            return null;\n        }\n        const $target = $(\"<div />\").attr({ id: selector.slice(1) });\n        $(\"body\").append($target);\n        return $target;\n    },\n\n    stopBubblingFromRemovedElement($el, cfgs, ev) {\n        /* IE8 fix. Stop event from propagating IF $el will be removed\n         * from the DOM. With pat-inject, often $el is the target that\n         * will itself be replaced with injected content.\n         *\n         * IE8 cannot handle events bubbling up from an element removed\n         * from the DOM.\n         *\n         * See: http://stackoverflow.com/questions/7114368/why-is-jquery-remove-throwing-attr-exception-in-ie8\n         */\n        for (const cfg of cfgs) {\n            const sel = cfg.target;\n            if ($el.parents(sel).addBack(sel) && !ev.isPropagationStopped()) {\n                ev.stopPropagation();\n                return;\n            }\n        }\n    },\n\n    _performInjection(target, $el, $source, cfg, trigger, title) {\n        /* Called after the XHR has succeeded and we have a new $source\n         * element to inject.\n         */\n        if (cfg.sourceMod === \"content\") {\n            $source = $source.contents();\n        }\n        let $src;\n        // $source.clone() does not work with shived elements in IE8\n        if (document.all && document.querySelector && !document.addEventListener) {\n            $src = $source.map((idx, el) => $(el.outerHTML)[0]);\n        } else {\n            $src = $source.safeClone();\n        }\n\n        $src.findInclusive(\"img\").on(\"load\", (e) => {\n            $(e.currentTarget).trigger(\"pat-inject-content-loaded\");\n        });\n\n        const $injected = cfg.$injected || $src;\n        // Now the injection actually happens.\n        if (this._inject(trigger, $src, $(target), cfg)) {\n            this._afterInjection($el, $injected, cfg);\n        }\n        // History support. if subform is submitted, append form params\n        const glue = cfg.url.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n        if (cfg.history === \"record\" && \"pushState\" in history) {\n            if (cfg.params) {\n                history.pushState(\n                    { url: cfg.url + glue + cfg.params },\n                    \"\",\n                    cfg.url + glue + cfg.params\n                );\n            } else {\n                history.pushState({ url: cfg.url }, \"\", cfg.url);\n            }\n            // Also inject title element if we have one\n            if (title)\n                this._inject(trigger, title, $(\"title\"), {\n                    action: \"element\",\n                });\n        }\n    },\n\n    _afterInjection($el, $injected, cfg) {\n        /* Set a class on the injected elements and fire the\n         * patterns-injected event.\n         */\n        $injected\n            .filter((idx, el_) => {\n                // setting data on textnode fails in IE8\n                return el_.nodeType !== TEXT_NODE;\n            })\n            .data(\"pat-injected\", { origin: cfg.url });\n\n        if ($injected.length === 1 && $injected[0].nodeType == TEXT_NODE) {\n            // Only one element injected, and it was a text node.\n            // So we trigger \"patterns-injected\" on the parent.\n            // The event handler should check whether the\n            // injected element and the triggered element are\n            // the same.\n            $injected.parent().trigger(\"patterns-injected\", [cfg, $el[0], $injected[0]]);\n        } else {\n            $injected.each((idx, el_) => {\n                // patterns-injected event will be triggered for each injected (non-text) element.\n                if (el_.nodeType !== TEXT_NODE) {\n                    $(el_)\n                        .addClass(cfg[\"class\"])\n                        .trigger(\"patterns-injected\", [cfg, $el[0], el_]);\n                }\n            });\n        }\n\n        if (cfg.scroll && cfg.scroll !== \"none\") {\n            let scroll_container = cfg.$target.parents().addBack().filter(\":scrollable\");\n            scroll_container = scroll_container.length ? scroll_container[0] : window;\n\n            // default for scroll===top\n            let top = 0;\n            let left = 0;\n\n            if (cfg.scroll !== \"top\") {\n                const scroll_target =\n                    cfg.scroll === \"target\"\n                        ? cfg.$target[0]\n                        : $injected.filter(cfg.scroll)[0];\n\n                // Get the reference element to which against we calculate\n                // the relative position of the target.\n                // In case of a scroll container of window, we do not have\n                // getBoundingClientRect method, so get the body instead.\n                const scroll_container_ref =\n                    scroll_container === window ? document.body : scroll_container;\n\n                // Calculate absolute [¹] position difference between\n                // scroll_container and scroll_target.\n                // Substract the container's border from the scrolling\n                // value, as this one isn't respected by\n                // getBoundingClientRect [²] and would lead to covered\n                // items [³].\n                // ¹) so that it doesn't make a difference, if the element\n                // is below or above the scrolling container. We just need\n                // to know the absolute difference.\n                // ²) Calculations are based from the viewport.\n                // ³) See:\n                //      https://docs.microsoft.com/en-us/previous-versions//hh781509(v=vs.85)\n                //      https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n                left = Math.abs(\n                    scroll_target.getBoundingClientRect().left +\n                        scroll_container_ref.scrollLeft -\n                        scroll_container_ref.getBoundingClientRect().left -\n                        dom.get_css_value(\n                            scroll_container_ref,\n                            \"border-left-width\",\n                            true\n                        )\n                );\n                top = Math.abs(\n                    scroll_target.getBoundingClientRect().top +\n                        scroll_container_ref.scrollTop -\n                        scroll_container_ref.getBoundingClientRect().top -\n                        dom.get_css_value(scroll_container_ref, \"border-top-width\", true)\n                );\n            }\n            if (scroll_container === window) {\n                scroll_container.scrollTo(left, top);\n            } else {\n                scroll_container.scrollLeft = left;\n                scroll_container.scrollTop = top;\n            }\n        }\n\n        $el[0].dispatchEvent(\n            new Event(\"pat-inject-success\", { bubbles: true, cancelable: true })\n        );\n    },\n\n    async _onInjectSuccess($el, cfgs, ev) {\n        let data = ev && ev.jqxhr && ev.jqxhr.responseText;\n        if (!data) {\n            log.warn(\"No response content, aborting\", ev);\n            return;\n        }\n        if (cfgs[0].source === \"none\") {\n            // Special case, we want to call something, but we don't want to inject anything\n            data = \"\";\n        }\n        $.each(cfgs[0].hooks || [], (idx, hook) =>\n            $el.trigger(\"pat-inject-hook-\" + hook)\n        );\n        this.stopBubblingFromRemovedElement($el, cfgs, ev);\n        const sources$ = await this.callTypeHandler(cfgs[0].dataType, \"sources\", $el, [\n            cfgs,\n            data,\n            ev,\n        ]);\n        /* pick the title source for dedicated handling later\n          Title - if present - is always appended at the end. */\n        let title;\n        if (\n            sources$ &&\n            sources$[sources$.length - 1] &&\n            sources$[sources$.length - 1][0] &&\n            sources$[sources$.length - 1][0].nodeName == \"TITLE\"\n        ) {\n            title = sources$[sources$.length - 1];\n        }\n        cfgs.forEach((cfg, idx1) => {\n            const perform_inject = () => {\n                if (cfg.target != \"none\")\n                    cfg.$target.each((idx2, target) => {\n                        this._performInjection(\n                            target,\n                            $el,\n                            sources$[idx1],\n                            cfg,\n                            ev.target,\n                            title\n                        );\n                    });\n            };\n            if (cfg.processDelay) {\n                setTimeout(() => perform_inject(), cfg.processDelay);\n            } else {\n                perform_inject();\n            }\n        });\n        if (cfgs[0].nextHref && $el.is(\"a\")) {\n            // In case next-href is specified the anchor's href will\n            // be set to it after the injection is triggered.\n            $el.attr({ href: cfgs[0].nextHref.replace(/&amp;/g, \"&\") });\n            this.destroy($el);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n    },\n\n    async _onInjectError($el, cfgs, event) {\n        let explanation = \"\";\n        const status = event.jqxhr.status;\n        const timestamp = new Date();\n        if (status % 100 == 4) {\n            explanation =\n                \"Sorry! We couldn't find the page to load. Please make a screenshot and send it to support. Thank you!\";\n        } else if (status % 100 == 5) {\n            explanation =\n                \"I am very sorry! There was an error at the server. Please make a screenshot and contact support. Thank you!\";\n        } else if (status == 0) {\n            explanation =\n                \"It seems, the server is down. Please make a screenshot and contact support. Thank you!\";\n        }\n\n        let error_page;\n        let error_page_fragment;\n        const url_params = new URLSearchParams(window.location.search);\n        if (url_params.get(\"pat-inject-errorhandler.off\") === null) {\n            // Prepare a error page to be injected into the document.\n\n            // Try to get a suitable error message from pre-configured error pages.\n            const error_page_url = document\n                .querySelector(`meta[name^=pat-inject-status-${status}]`)\n                ?.getAttribute(\"content\", false);\n            error_page_fragment = error_page_url?.split(\"#\")[1];\n            error_page_fragment = error_page_fragment ? `#${error_page_fragment}` : null;\n\n            if (error_page_fragment) {\n                error_page = document.createElement(\"html\");\n                error_page.innerHTML = event.jqxhr.responseText;\n                error_page = error_page.querySelector(error_page_fragment);\n            }\n\n            if (!error_page && error_page_url) {\n                try {\n                    const error_page_response = await fetch(error_page_url, {\n                        method: \"GET\",\n                    });\n                    error_page = document.createElement(\"html\");\n                    error_page.innerHTML = await error_page_response.text();\n                    error_page = error_page.querySelector(error_page_fragment || \"body\");\n                } catch {\n                    // fall back to standard error message and ignore.\n                }\n            }\n        }\n\n        // clean up\n        cfgs.forEach((cfg) => {\n            if (\"$injected\" in cfg) {\n                cfg.$injected.remove();\n            }\n            cfg.$target.removeClass(cfg.loadingClass);\n            $el.removeClass(cfg.executingClass);\n        });\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n\n        if (error_page) {\n            const error_zone = document.querySelector(error_page_fragment || \"body\");\n            error_zone.innerHTML = error_page.innerHTML;\n            registry.scan(error_zone); // initialize any patterns in error page\n        } else {\n            const msg_attr = `${explanation} Status is ${status} ${event.jqxhr.statusText}, time was ${timestamp}. You can click to close this.`;\n            $(\"body\").attr(\"data-error-message\", msg_attr);\n            $(\"body\").on(\"click\", () => {\n                $(\"body\").removeAttr(\"data-error-message\");\n                window.location.href = window.location.href; // reload\n            });\n        }\n    },\n\n    execute(cfgs, $el) {\n        /* Actually execute the injection.\n         *\n         * Either by making an ajax request or by spoofing an ajax\n         * request when the content is readily available in the current page.\n         */\n        // get a kinda deep copy, we scribble on it\n        cfgs = cfgs.map((cfg) => $.extend({}, cfg));\n        if (!this.verifyConfig(cfgs)) {\n            return;\n        }\n        if (!this.askForConfirmation(cfgs)) {\n            return;\n        }\n        if ($el.data(\"pat-inject-triggered\")) {\n            // Prevent double triggers;\n            return;\n        }\n        $el.data(\"pat-inject-triggered\", true);\n        // possibility for spinners on targets\n        _.chain(cfgs)\n            .filter(_.property(\"loadingClass\"))\n            .each((cfg) => {\n                if (cfg.target != \"none\") cfg.$target.addClass(cfg.loadingClass);\n            });\n        // Put the execute class on the elem that has pat inject on it\n        _.chain(cfgs)\n            .filter(_.property(\"loadingClass\"))\n            .each((cfg) => $el.addClass(cfg.executingClass));\n\n        $el.on(\n            \"pat-ajax-success.pat-inject\",\n            this._onInjectSuccess.bind(this, $el, cfgs)\n        );\n        $el.on(\"pat-ajax-error.pat-inject\", this._onInjectError.bind(this, $el, cfgs));\n        $el.on(\"pat-ajax-success.pat-inject pat-ajax-error.pat-inject\", () =>\n            $el.removeData(\"pat-inject-triggered\")\n        );\n\n        if (cfgs[0].url.length) {\n            ajax.request($el, { url: cfgs[0].url });\n        } else {\n            // If there is no url specified, then content is being fetched\n            // from the same page.\n            // No need to do an ajax request for this, so we spoof the ajax\n            // event.\n            $el.trigger({\n                type: \"pat-ajax-success\",\n                jqxhr: {\n                    responseText: $(\"body\").html(),\n                },\n            });\n        }\n    },\n\n    _inject(trigger, $source, $target, cfg) {\n        // action to jquery method mapping, except for \"content\"\n        // and \"element\"\n        const method = {\n            contentbefore: \"prepend\",\n            contentafter: \"append\",\n            elementbefore: \"before\",\n            elementafter: \"after\",\n        }[cfg.action];\n\n        if (cfg.source === \"none\") {\n            $target.replaceWith(\"\");\n            return true;\n        }\n        if ($source.length === 0) {\n            log.warn(\"Aborting injection, source not found:\", $source);\n            $(trigger).trigger(\"pat-inject-missingSource\", {\n                url: cfg.url,\n                selector: cfg.source,\n            });\n            return false;\n        }\n        if (cfg.target === \"none\")\n            // Special case. Don't do anything, we don't want any result\n            return true;\n        if ($target.length === 0) {\n            log.warn(\"Aborting injection, target not found:\", $target);\n            $(trigger).trigger(\"pat-inject-missingTarget\", {\n                selector: cfg.target,\n            });\n            return false;\n        }\n        if (cfg.action === \"content\") {\n            $target.empty().append($source);\n        } else if (cfg.action === \"element\") {\n            $target.replaceWith($source);\n        } else {\n            $target[method]($source);\n        }\n        return true;\n    },\n\n    _sourcesFromHtml(html, url, sources) {\n        const $html = this._parseRawHtml(html, url);\n        return sources.map((source) => {\n            if (source === \"body\") {\n                source = \"#__original_body\";\n            }\n            if (source === \"none\") {\n                return $(\"<!-- -->\");\n            }\n            const $source = $html.find(source);\n\n            if ($source.length === 0) {\n                if (source != \"title\") {\n                    log.warn(\"No source elements for selector:\", source, $html);\n                }\n            }\n\n            $source.find('a[href^=\"#\"]').each((idx, el_) => {\n                const href = el_.getAttribute(\"href\");\n                if (href.indexOf(\"#{1}\") !== -1) {\n                    // We ignore hrefs containing #{1} because they're not\n                    // valid and only applicable in the context of\n                    // pat-clone.\n                    return;\n                }\n                // Skip in-document links pointing to an id that is inside\n                // this fragment.\n                if (href.length === 1) {\n                    // Special case for top-of-page links\n                    el_.href = url;\n                } else if (!$source.find(href).length) {\n                    el_.href = url + href;\n                }\n            });\n            return $source;\n        });\n    },\n\n    _rebaseAttrs: {\n        A: \"href\",\n        FORM: \"action\",\n        IMG: \"data-pat-inject-rebase-src\",\n        OBJECT: \"data\",\n        SOURCE: \"data-pat-inject-rebase-src\",\n        VIDEO: \"data-pat-inject-rebase-src\",\n    },\n\n    _rebaseOptions: {\n        \"calendar\": [\"url\", \"event-sources\"],\n        \"collapsible\": [\"load-content\"],\n        \"date-picker\": [\"i18n\"],\n        \"datetime-picker\": [\"i18n\"],\n        \"inject\": [\"url\"],\n    },\n\n    _rebaseHTML(base, html) {\n        if (html === \"\") {\n            // Special case, source is none\n            return \"\";\n        }\n        const $page = $(\n            html.replace(/(\\s)(src\\s*)=/gi, '$1src=\"\" data-pat-inject-rebase-$2=').trim()\n        )\n            .wrapAll(\"<div>\")\n            .parent();\n\n        $page.find(Object.keys(this._rebaseAttrs).join(\",\")).each((idx, el_) => {\n            const $el_ = $(el_);\n            const attrName = this._rebaseAttrs[el_.tagName];\n            let value = $el_.attr(attrName);\n\n            if (\n                value &&\n                value.slice(0, 2) !== \"@@\" &&\n                value[0] !== \"#\" &&\n                value.slice(0, 7) !== \"mailto:\" &&\n                value.slice(0, 4) !== \"tel:\" &&\n                value.slice(0, 4) !== \"fax:\" &&\n                value.slice(0, 7) !== \"callto:\" &&\n                value.slice(0, 10) !== \"ts3server:\" &&\n                value.slice(0, 6) !== \"teams:\" &&\n                value.slice(0, 11) !== \"javascript:\"\n            ) {\n                value = utils.rebaseURL(base, value);\n                $el_.attr(attrName, value);\n            }\n        });\n\n        for (const [pattern_name, opts] of Object.entries(this._rebaseOptions)) {\n            for (const el_ of dom.querySelectorAllAndMe(\n                $page[0],\n                `[data-pat-${pattern_name}]`\n            )) {\n                const pattern = registry.patterns?.[pattern_name];\n                const pattern_parser = pattern?.parser;\n                if (!pattern_parser) {\n                    continue;\n                }\n                // parse: no default options, possibly multiple configs, no grouping.\n                const options = pattern_parser.parse(el_, {}, true, false, false);\n                let changed = false;\n                for (const config of options) {\n                    for (const opt of opts) {\n                        const val = config[opt];\n                        if (!val) {\n                            continue;\n                        }\n                        changed = true;\n                        if (Array.isArray(val)) {\n                            config[opt] = val.map((it) => utils.rebaseURL(base, it));\n                        } else {\n                            config[opt] = utils.rebaseURL(base, val);\n                        }\n                    }\n                }\n                if (changed) {\n                    el_.setAttribute(\n                        `data-pat-${pattern_name}`,\n                        JSON.stringify(options.length === 1 ? options[0] : options)\n                    );\n                }\n            }\n        }\n\n        // XXX: IE8 changes the order of attributes in html. The following\n        // lines move data-pat-inject-rebase-src to src.\n        $page.find(\"[data-pat-inject-rebase-src]\").each((id, el_) => {\n            const $el = $(el_);\n            $el.attr(\"src\", $el.attr(\"data-pat-inject-rebase-src\")).removeAttr(\n                \"data-pat-inject-rebase-src\"\n            );\n        });\n\n        return $page\n            .html()\n            .replace(/src=\"\" data-pat-inject-rebase-/g, \"\")\n            .trim();\n    },\n\n    _parseRawHtml(html, url) {\n        url = url || \"\";\n\n        // remove script tags and head and replace body by a div\n        const title = html.match(/\\<title\\>(.*)\\<\\/title\\>/);\n        let clean_html = html\n            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n            .replace(/<head\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/head>/gi, \"\")\n            .replace(/<body([^>]*?)>/gi, '<div id=\"__original_body\">')\n            .replace(/<\\/body([^>]*?)>/gi, \"</div>\");\n        if (title && title.length == 2) {\n            clean_html = title[0] + clean_html;\n        }\n        try {\n            clean_html = this._rebaseHTML(url, clean_html);\n        } catch (e) {\n            log.error(\"Error rebasing urls\", e);\n        }\n        const $html = $(\"<div/>\").html(clean_html);\n        if ($html.children().length === 0) {\n            log.warn(\"Parsing html resulted in empty jquery object:\", clean_html);\n        }\n        return $html;\n    },\n\n    _initAutoloadVisible($el, cfgs) {\n        if ($el.data(\"pat-inject-autoloaded\")) {\n            // ignore executed autoloads\n            return false;\n        }\n\n        const el = $el[0];\n\n        // delay: default is 200ms to allow scrolling over and past autoload-visible elements without loading them.\n        const delay = cfgs[0].delay || 200;\n        log.debug(`Delay time: ${delay}`);\n\n        // function to trigger the autoload and mark as triggered\n        const trigger = (event) => {\n            if ($el.data(\"pat-inject-autoloaded\")) {\n                log.debug(`autoload-visible trigger skipped ${el}`);\n                return false;\n            }\n            $el.data(\"pat-inject-autoloaded\", true);\n            this.onTrigger({ currentTarget: el });\n            event && event.preventDefault();\n            log.debug(`autoload-visible trigger run ${el}`);\n            return true;\n        };\n\n        // Config see: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n        const intersection_observer_config = {\n            threshold: 0, // If even one pixel is visible, the callback will be run.\n            root: null, // Root is browser viewport. If the element is visible to the user, the callback will be run.\n            margin: \"0px\", // No margins. The element is not preloaded.\n        };\n\n        let timeout_id = null;\n        const observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting) {\n                    // Run the callback after 200ms to prevent loading all\n                    // visible elements when scrolling over.\n                    timeout_id = window.setTimeout(() => {\n                        observer.disconnect(); // Stop observing loaded elements.\n                        trigger();\n                    }, delay);\n                    log.debug(`autoload-visible intersecting ${el}`);\n                } else {\n                    window.clearTimeout(timeout_id);\n                    log.debug(`autoload-visible not intersecting ${el}`);\n                }\n            }\n        }, intersection_observer_config);\n        observer.observe(el);\n    },\n\n    _initIdleTrigger($el, delay) {\n        // XXX TODO: handle item removed from DOM\n        const timeout = parseInt(delay, 10);\n        let timer;\n\n        const onTimeout = () => {\n            this.onTrigger({ currentTarget: $el[0] });\n            unsub();\n            clearTimeout(timer);\n        };\n\n        const onInteraction = utils.debounce(() => {\n            if (!document.body.contains($el[0])) {\n                unsub();\n                return;\n            }\n            clearTimeout(timer);\n            timer = setTimeout(onTimeout, timeout);\n        }, timeout);\n\n        const unsub = () => {\n            [\"scroll\", \"resize\"].forEach((e) =>\n                window.removeEventListener(e, onInteraction)\n            );\n            [\n                \"click\",\n                \"keypress\",\n                \"keyup\",\n                \"mousemove\",\n                \"touchstart\",\n                \"touchend\",\n            ].forEach((e) => document.removeEventListener(e, onInteraction));\n        };\n\n        onInteraction();\n\n        [\"scroll\", \"resize\"].forEach((e) => window.addEventListener(e, onInteraction));\n        [\"click\", \"keypress\", \"keyup\", \"mousemove\", \"touchstart\", \"touchend\"].forEach(\n            (e) => document.addEventListener(e, onInteraction)\n        );\n    },\n\n    // XXX: simple so far to see what the team thinks of the idea\n    registerTypeHandler(type, handler) {\n        this.handlers[type] = handler;\n    },\n\n    async callTypeHandler(type, fn, context, params) {\n        type = type || \"html\";\n        if (this.handlers[type] && $.isFunction(this.handlers[type][fn])) {\n            return await this.handlers[type][fn].bind(this)(...params);\n        } else {\n            return null;\n        }\n    },\n\n    handlers: {\n        html: {\n            sources(cfgs, data) {\n                const sources = cfgs.map((cfg) => cfg.source);\n                sources.push(\"title\");\n                return this._sourcesFromHtml(data, cfgs[0].url, sources);\n            },\n        },\n    },\n};\n\n$(document).on(\"patterns-injected.inject\", (ev, cfg, trigger, injected) => {\n    /* Listen for the patterns-injected event.\n     *\n     * Remove the \"loading-class\" classes from all injection targets and\n     * then scan the injected content for new patterns.\n     */\n    if (cfg && cfg.skipPatInjectHandler) {\n        // Allow skipping this handler but still have other handlers in other\n        // patterns listen to ``patterns-injected``.\n        return;\n    }\n    if (cfg) {\n        cfg.$target.removeClass(cfg.loadingClass);\n        // Remove the executing class, add the executed class to the element with pat.inject on it.\n        $(trigger).removeClass(cfg.executingClass).addClass(cfg.executedClass);\n    }\n    if (injected.nodeType !== TEXT_NODE && injected !== COMMENT_NODE) {\n        registry.scan(injected, null, { type: \"injection\", element: trigger });\n        $(injected).trigger(\"patterns-injected-scanned\");\n    }\n});\n\n$(window).on(\"popstate\", (event) => {\n    // popstate also triggers on traditional anchors\n    if (!event.originalEvent.state && \"replaceState\" in history) {\n        try {\n            history.replaceState(\"anchor\", \"\", document.location.href);\n        } catch (e) {\n            log.debug(e);\n        }\n        return;\n    }\n    // Not only change the URL, also reload the page.\n    window.location.reload();\n});\n\n// this entry ensures that the initally loaded page can be reached with\n// the back button\nif (\"replaceState\" in history) {\n    try {\n        history.replaceState(\"pageload\", \"\", document.location.href);\n    } catch (e) {\n        log.debug(e);\n    }\n}\n\nregistry.register(inject);\nexport default inject;\n","import \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["methods","init","options","settings","time","initialTime","exceptionAreas","this","each","$this","data","lastEvent","Date","trueTime","untouched","inExceptionArea","on","mouseMoved","find","live","parent","enteredException","leftException","timeout","addClass","event","trigger","destroy","window","off","remove","removeData","hasClass","removeClass","startTimer","fn","setTimeout","Math","floor","now","diff","method","apply","Array","prototype","slice","call","arguments","scrollable","element","css","clientHeight","scrollHeight","clientWidth","scrollWidth","parent_id","absoluteParent","parents","length","elemTop","position","top","elemBottom","height","viewTop","scrollTop","viewBottom","docElem","elem","origin","left","nodeType","ownerDocument","document","documentElement","offsettop","offsetleft","thiswidth","width","pos","safeOffset","setleft","settop","appendTo","show","selector","$ancestor","closest","$child","childMarginEdgeLeft","parseInt","childMarginEdgeTop","ancestorPaddingEdgeLeft","ancestorPaddingEdgeTop","addBack","filter","speed","easing","callback","animate","a","i","m","text","toUpperCase","indexOf","log","logging","addArgument","$el","is","attr","split","cache","xhrCount","undefined","get","_","name","parser","onTriggerEvents","onClickSubmit","warn","el","target","form","value","preventDefault","request","opts","_request","cfg","parse","seqNumber","inc","url","temp","clickedData","args","context","serialize","Boolean","join","headers","accept","Accept","formdata","FormData","key","append","debug","ajax_deferred","done","status","jqxhr","type","fail","error","registry","inject","cfgs","extractConfig","some","e","history","nextHref","href","location","pushMarker","onTrigger","currentTarget","idleTrigger","_initIdleTrigger","forEach","delay","processDelay","bind","ajax","onFormActionSubmit","uid","random","toString","delayed_trigger","uid_","_initAutoloadVisible","v","params","serializeArray","execute","$button","formaction","$form","first","$cfg_node","submitSubform","$sub","$context","urlparts","defaultSelector","utils","elementIsDirty","val","askForConfirmation","message","should_confirm","_confirm","confirm","$target","confirmMessage","ensureTarget","createTarget","$injected","verifySingleConfig","source","extractModifiers","listenForFormReset","verifyConfig","every","html","source_match","exec","target_match","sourceMod","targetMod","targetPosition","loadingClass","action","id","stopBubblingFromRemovedElement","ev","sel","isPropagationStopped","stopPropagation","_performInjection","$source","title","$src","contents","all","querySelector","addEventListener","map","idx","outerHTML","safeClone","findInclusive","_inject","_afterInjection","glue","pushState","el_","scroll","scroll_container","scroll_target","scroll_container_ref","body","abs","getBoundingClientRect","scrollLeft","dom","scrollTo","dispatchEvent","Event","bubbles","cancelable","async","responseText","hooks","hook","sources$","callTypeHandler","dataType","nodeName","idx1","perform_inject","idx2","replace","explanation","timestamp","error_page","error_page_fragment","URLSearchParams","search","error_page_url","getAttribute","createElement","innerHTML","error_page_response","fetch","executingClass","error_zone","msg_attr","statusText","removeAttr","_onInjectSuccess","_onInjectError","contentbefore","contentafter","elementbefore","elementafter","replaceWith","empty","_sourcesFromHtml","sources","$html","_parseRawHtml","_rebaseAttrs","A","FORM","IMG","OBJECT","SOURCE","VIDEO","_rebaseOptions","_rebaseHTML","base","$page","trim","wrapAll","Object","keys","$el_","attrName","tagName","pattern_name","entries","pattern","pattern_parser","changed","config","opt","isArray","it","setAttribute","JSON","stringify","match","clean_html","children","timeout_id","observer","IntersectionObserver","entry","isIntersecting","disconnect","clearTimeout","threshold","root","margin","observe","timer","onTimeout","unsub","onInteraction","contains","removeEventListener","registerTypeHandler","handler","handlers","push","injected","skipPatInjectHandler","executedClass","originalEvent","state","reload","replaceState","is_markdown_resource","Markdown","render","replaceAll","Showdown","default","extensions","prettify","pre","$rendering","converter","Converter","tables","makeHtml","header","extractSection","level","matcher","RegExp","ready","test","Promise","pat","renderForInjection"],"sourceRoot":""}