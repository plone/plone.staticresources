{"version":3,"file":"chunks/72908.a60ee9d6559eb141470c.min.js","mappings":"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","sources":["webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/core/jquery-ext.js","webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/ajax/ajax.js","webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/inject/inject.js","webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["/**\n * @license\n * Patterns @VERSION@ jquery-ext - various jQuery extensions\n *\n * Copyright 2011 Humberto SermeÃ±o\n */\n\nimport $ from \"jquery\";\n\nvar methods = {\n    init: function (options) {\n        var settings = {\n            time: 3 /* time it will wait before moving to \"timeout\" after a move event */,\n            initialTime: 8 /* time it will wait before first adding the \"timeout\" class */,\n            exceptionAreas: [] /* IDs of elements that, if the mouse is over them, will reset the timer */,\n        };\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            if (!data) {\n                if (options) {\n                    $.extend(settings, options);\n                }\n                $this.data(\"timeout\", {\n                    lastEvent: new Date(),\n                    trueTime: settings.time,\n                    time: settings.initialTime,\n                    untouched: true,\n                    inExceptionArea: false,\n                });\n\n                $this.on(\"mouseover.timeout\", methods.mouseMoved);\n                $this.on(\"mouseenter.timeout\", methods.mouseMoved);\n\n                $(settings.exceptionAreas).each(function () {\n                    $this\n                        .find(this)\n                        .live(\n                            \"mouseover.timeout\",\n                            { parent: $this },\n                            methods.enteredException\n                        )\n                        .live(\n                            \"mouseleave.timeout\",\n                            { parent: $this },\n                            methods.leftException\n                        );\n                });\n\n                if (settings.initialTime > 0) $this.timeout(\"startTimer\");\n                else $this.addClass(\"timeout\");\n            }\n        });\n    },\n\n    enteredException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = true;\n        event.data.parent.data(\"timeout\", data);\n        event.data.parent.trigger(\"mouseover\");\n    },\n\n    leftException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = false;\n        event.data.parent.data(\"timeout\", data);\n    },\n\n    destroy: function () {\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            $(window).off(\".timeout\");\n            data.timeout.remove();\n            $this.removeData(\"timeout\");\n        });\n    },\n\n    mouseMoved: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n\n        if ($this.hasClass(\"timeout\")) {\n            $this.removeClass(\"timeout\");\n            $this.timeout(\"startTimer\");\n        } else if (data.untouched) {\n            data.untouched = false;\n            data.time = data.trueTime;\n        }\n\n        data.lastEvent = new Date();\n        $this.data(\"timeout\", data);\n    },\n\n    startTimer: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n        var fn = function () {\n            var data = $this.data(\"timeout\");\n            if (data && data.lastEvent) {\n                if (data.inExceptionArea) {\n                    setTimeout(fn, Math.floor(data.time * 1000));\n                } else {\n                    var now = new Date();\n                    var diff = Math.floor(data.time * 1000) - (now - data.lastEvent);\n                    if (diff > 0) {\n                        // the timeout has not ocurred, so set the timeout again\n                        setTimeout(fn, diff + 100);\n                    } else {\n                        // timeout ocurred, so set the class\n                        $this.addClass(\"timeout\");\n                    }\n                }\n            }\n        };\n\n        setTimeout(fn, Math.floor(data.time * 1000));\n    },\n};\n\n$.fn.timeout = function (method) {\n    if (methods[method]) {\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof method === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n    } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timeout\");\n    }\n};\n\n// Custom jQuery selector to find elements with scrollbars\n$.extend($.expr[\":\"], {\n    scrollable: function (element) {\n        var vertically_scrollable, horizontally_scrollable;\n        if (\n            $(element).css(\"overflow\") === \"scroll\" ||\n            $(element).css(\"overflowX\") === \"scroll\" ||\n            $(element).css(\"overflowY\") === \"scroll\"\n        )\n            return true;\n\n        vertically_scrollable =\n            element.clientHeight < element.scrollHeight &&\n            ($.inArray($(element).css(\"overflowY\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n\n        if (vertically_scrollable) return true;\n\n        horizontally_scrollable =\n            element.clientWidth < element.scrollWidth &&\n            ($.inArray($(element).css(\"overflowX\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n        return horizontally_scrollable;\n    },\n});\n\n// Make Visible in scroll\n$.fn.makeVisibleInScroll = function (parent_id) {\n    var absoluteParent = null;\n    if (typeof parent_id === \"string\") {\n        absoluteParent = $(\"#\" + parent_id);\n    } else if (parent_id) {\n        absoluteParent = $(parent_id);\n    }\n\n    return this.each(function () {\n        var $this = $(this),\n            parent;\n        if (!absoluteParent) {\n            parent = $this.parents(\":scrollable\");\n            if (parent.length > 0) {\n                parent = $(parent[0]);\n            } else {\n                parent = $(window);\n            }\n        } else {\n            parent = absoluteParent;\n        }\n\n        var elemTop = $this.position().top;\n        var elemBottom = $this.height() + elemTop;\n\n        var viewTop = parent.scrollTop();\n        var viewBottom = parent.height() + viewTop;\n\n        if (elemTop < viewTop) {\n            parent.scrollTop(elemTop);\n        } else if (elemBottom > viewBottom - parent.height() / 2) {\n            parent.scrollTop(elemTop - (parent.height() - $this.height()) / 2);\n        }\n    });\n};\n\n//Work around warning for jQuery 3.x:\n//JQMIGRATE: jQuery.fn.offset() requires an element connected to a document\n$.fn.safeOffset = function () {\n    var docElem,\n        elem = this[0],\n        origin = { top: 0, left: 0 };\n\n    if (!elem || !elem.nodeType) {\n        return origin;\n    }\n\n    docElem = (elem.ownerDocument || document).documentElement;\n    if (!$.contains(docElem, elem)) {\n        return origin;\n    }\n\n    return $.fn.offset.apply(this, arguments);\n};\n\n//Make absolute location\n$.fn.setPositionAbsolute = function (element, offsettop, offsetleft) {\n    return this.each(function () {\n        // set absolute location for based on the element passed\n        // dynamically since every browser has different settings\n        var $this = $(this);\n        var thiswidth = $(this).width();\n        var pos = element.safeOffset();\n        var width = element.width();\n        var height = element.height();\n        var setleft = pos.left + width - thiswidth + offsetleft;\n        var settop = pos.top + height + offsettop;\n        $this.css({\n            \"z-index\": 1,\n            \"position\": \"absolute\",\n            \"marginLeft\": 0,\n            \"marginTop\": 0,\n            \"left\": setleft + \"px\",\n            \"top\": settop + \"px\",\n            \"width\": thiswidth,\n        });\n        $this.remove().appendTo(\"body\").show();\n    });\n};\n\n$.fn.positionAncestor = function (selector) {\n    var left = 0;\n    var top = 0;\n    this.each(function () {\n        // check if current element has an ancestor matching a selector\n        // and that ancestor is positioned\n        var $ancestor = $(this).closest(selector);\n        if ($ancestor.length && $ancestor.css(\"position\") !== \"static\") {\n            var $child = $(this);\n            var childMarginEdgeLeft =\n                $child.safeOffset().left - parseInt($child.css(\"marginLeft\"), 10);\n            var childMarginEdgeTop =\n                $child.safeOffset().top - parseInt($child.css(\"marginTop\"), 10);\n            var ancestorPaddingEdgeLeft =\n                $ancestor.safeOffset().left +\n                parseInt($ancestor.css(\"borderLeftWidth\"), 10);\n            var ancestorPaddingEdgeTop =\n                $ancestor.safeOffset().top +\n                parseInt($ancestor.css(\"borderTopWidth\"), 10);\n            left = childMarginEdgeLeft - ancestorPaddingEdgeLeft;\n            top = childMarginEdgeTop - ancestorPaddingEdgeTop;\n            // we have found the ancestor and computed the position\n            // stop iterating\n            return false;\n        }\n    });\n    return {\n        left: left,\n        top: top,\n    };\n};\n\n$.fn.findInclusive = function (selector) {\n    return this.find(\"*\").addBack().filter(selector);\n};\n\n$.fn.slideIn = function (speed, easing, callback) {\n    return this.animate({ width: \"show\" }, speed, easing, callback);\n};\n\n$.fn.slideOut = function (speed, easing, callback) {\n    return this.animate({ width: \"hide\" }, speed, easing, callback);\n};\n\n// case-insensitive :contains\n$.expr[\":\"].Contains = function (a, i, m) {\n    return $(a).text().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;\n};\n\n$.fn.scopedFind = function (selector) {\n    /*  If the selector starts with an object id do a global search,\n     *  otherwise do a local search.\n     */\n    if (selector.indexOf(\"#\") === 0) {\n        return $(selector);\n    } else {\n        return this.find(selector);\n    }\n};\n\nexport default undefined;\n","/**\n * Patterns ajax - AJAX injection for forms and anchors\n *\n * Copyright 2012-2013 Florian Friesdorf\n * Copyright 2012-2013 Marko Durkovic\n */\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\n\nconst log = logging.getLogger(\"pat.ajax\");\n\nexport const parser = new Parser(\"ajax\");\nparser.addArgument(\"accept\", \"text/html\");\nparser.addArgument(\"url\", function ($el) {\n    return (\n        $el.is(\"a\") ? $el.attr(\"href\") : $el.is(\"form\") ? $el.attr(\"action\") : \"\"\n    ).split(\"#\")[0];\n});\nparser.addArgument(\"browser-cache\", \"no-cache\", [\"cache\", \"no-cache\"]); // Cache ajax requests\n\nconst xhrCount = {};\nxhrCount.get = function (a) {\n    return this[a] !== undefined ? this[a] : 0;\n};\nxhrCount.inc = function (a) {\n    this[a] = this.get(a) + 1;\n    return this.get(a);\n};\n\nconst _ = {\n    name: \"ajax\",\n    trigger: \".pat-ajax\",\n    parser: parser,\n    init($el) {\n        $el.off(\".pat-ajax\");\n        $el.filter(\"a\").on(\"click.pat-ajax\", _.onTriggerEvents);\n        $el.filter(\"form\")\n            .on(\"submit.pat-ajax\", _.onTriggerEvents)\n            .on(\"click.pat-ajax\", \"[type=submit]\", _.onClickSubmit);\n        $el.filter(\":not(form,a)\").each(function () {\n            log.warn(\"Unsupported element:\", this);\n        });\n        return $el;\n    },\n    destroy($el) {\n        $el.off(\".pat-ajax\");\n    },\n    onClickSubmit(event) {\n        const el = event.target;\n        const form = el.closest(\"form\");\n        const data = {};\n        if (el.name) {\n            data[el.name] = el.value;\n        }\n        $(form).data(\"pat-ajax.clicked-data\", data);\n    },\n    onTriggerEvents(event) {\n        if (event) {\n            event.preventDefault();\n        }\n        _.request($(this));\n    },\n    request($el, opts) {\n        return $el.each(function () {\n            _._request($(this), opts);\n        });\n    },\n    _request($el, opts) {\n        const cfg = _.parser.parse($el, opts);\n        const onError = function (jqxhr, status, error) {\n            // error can also stem from a javascript\n            // exception, not only errors described in the\n            // jqxhr.\n            log.error(\"load error for \" + cfg.url + \":\", error, jqxhr);\n            $el.trigger({\n                type: \"pat-ajax-error\",\n                jqxhr: jqxhr,\n            });\n        };\n        const seqNumber = xhrCount.inc(cfg.url);\n        const onSuccess = function (data, status, jqxhr) {\n            log.debug(\"success: jqxhr:\", jqxhr);\n            if (seqNumber === xhrCount.get(cfg.url)) {\n                // if this url is requested multiple time, only return the last result\n                $el.trigger({\n                    type: \"pat-ajax-success\",\n                    jqxhr: jqxhr,\n                });\n            } else {\n                // ignore\n            }\n        };\n        const temp = $el.data(\"pat-ajax.clicked-data\");\n        const clickedData = temp ? $.param(temp) : \"\";\n        const args = {\n            context: $el,\n            data: [$el.serialize(), clickedData].filter(Boolean).join(\"&\"),\n            headers: {},\n            url: cfg.url,\n            method: $el.attr(\"method\") ? $el.attr(\"method\") : \"GET\",\n            cache: cfg.browserCache === \"cache\" ? true : false,\n        };\n\n        if (cfg.accept) {\n            args.headers.Accept = cfg.accept;\n        }\n\n        if (\n            $el.is(\"form\") &&\n            $el.attr(\"method\") &&\n            $el.attr(\"method\").toUpperCase() == \"POST\"\n        ) {\n            const formdata = new FormData($el[0]);\n            for (const key in temp) {\n                formdata.append(key, temp[key]);\n            }\n            args[\"method\"] = \"POST\";\n            args[\"data\"] = formdata;\n            args[\"cache\"] = false;\n            args[\"contentType\"] = false;\n            args[\"processData\"] = false;\n            args[\"type\"] = \"POST\";\n        }\n\n        $el.removeData(\"pat-ajax.clicked-data\");\n        log.debug(\"request:\", args, $el[0]);\n\n        // Make it happen\n        const ajax_deferred = $.ajax(args);\n\n        if (ajax_deferred) ajax_deferred.done(onSuccess).fail(onError);\n    },\n};\n\nregistry.register(_);\n\nexport default _;\n","import \"../../core/jquery-ext\"; // for :scrollable for autoLoading-visible\nimport \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport ajax from \"../ajax/ajax\";\nimport dom from \"../../core/dom\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.inject\");\n//log.setLevel(logging.Level.DEBUG);\n\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\n\nexport const parser = new Parser(\"inject\");\nparser.addArgument(\"default-selector\");\nparser.addArgument(\"target\");\nparser.addArgument(\"data-type\", \"html\");\nparser.addArgument(\"next-href\");\nparser.addArgument(\"source\");\nparser.addArgument(\"trigger\", \"default\", [\n    \"default\",\n    \"autoload\",\n    \"autoload-visible\",\n    \"idle\",\n]);\nparser.addArgument(\"delay\"); // only used in autoload\nparser.addArgument(\"browser-cache\", \"no-cache\", [\"cache\", \"no-cache\"]); // Cache ajax requests. Pass to pat-ajax.\nparser.addArgument(\"confirm\", \"class\", [\"never\", \"always\", \"form-data\", \"class\"]);\nparser.addArgument(\"confirm-message\", \"Are you sure you want to leave this page?\");\nparser.addArgument(\"hooks\", [], [\"raptor\"], true); // After injection, pat-inject will trigger an event for each hook: pat-inject-hook-$(hook)\nparser.addArgument(\"loading-class\", \"injecting\"); // Add a class to the target while content is still loading.\nparser.addArgument(\"executing-class\", \"executing\"); // Add a class to the element while content is still loading.\nparser.addArgument(\"executed-class\", \"executed\"); // Add a class to the element when content is loaded.\nparser.addArgument(\"class\"); // Add a class to the injected content.\nparser.addArgument(\"history\");\nparser.addArgument(\"push-marker\");\nparser.addArgument(\"scroll\");\n// XXX: this should not be here but the parser would bail on\n// unknown parameters and expand/collapsible need to pass the url\n// to us\nparser.addArgument(\"url\");\n\nconst inject = {\n    name: \"inject\",\n    trigger:\n        \".raptor-ui .ui-button.pat-inject, a.pat-inject, form.pat-inject, .pat-subform.pat-inject\",\n    parser: parser,\n\n    init($el, opts) {\n        const cfgs = this.extractConfig($el, opts);\n        if (cfgs.some((e) => e.history === \"record\") && !(\"pushState\" in history)) {\n            // if the injection shall add a history entry and HTML5 pushState\n            // is missing, then don't initialize the injection.\n            return $el;\n        }\n        $el.data(\"pat-inject\", cfgs);\n\n        if (cfgs[0].nextHref && cfgs[0].nextHref.indexOf(\"#\") === 0) {\n            // In case the next href is an anchor, and it already\n            // exists in the page, we do not activate the injection\n            // but instead just change the anchors href.\n\n            // XXX: This is used in only one project for linked\n            // fullcalendars, it's sanity is wonky and we should\n            // probably solve it differently.\n            if ($el.is(\"a\") && $(cfgs[0].nextHref).length > 0) {\n                log.debug(\n                    \"Skipping as next href is anchor, which already exists\",\n                    cfgs[0].nextHref\n                );\n                // XXX: reconsider how the injection enters exhausted state\n                return $el.attr({\n                    href: (window.location.href.split(\"#\")[0] || \"\") + cfgs[0].nextHref,\n                });\n            }\n        }\n        if (cfgs[0].pushMarker) {\n            $(\"body\").on(\"push\", (event, data) => {\n                log.debug(\"received push message: \" + data);\n                if (data == cfgs[0].pushMarker) {\n                    log.debug(\"re-injecting \" + data);\n                    this.onTrigger({ currentTarget: $el[0] });\n                }\n            });\n        }\n        if (cfgs[0].idleTrigger) {\n            this._initIdleTrigger($el, cfgs[0].idleTrigger);\n        } else {\n            switch (cfgs[0].trigger) {\n                case \"default\":\n                    cfgs.forEach((cfg) => {\n                        if (cfg.delay) {\n                            cfg.processDelay = cfg.delay;\n                        }\n                    });\n                    // setup event handlers\n                    if ($el.is(\"form\")) {\n                        $el.on(\"submit.pat-inject\", this.onTrigger.bind(this))\n                            .on(\"click.pat-inject\", \"[type=submit]\", ajax.onClickSubmit)\n                            .on(\n                                \"click.pat-inject\",\n                                \"[type=submit][formaction], [type=image][formaction]\",\n                                this.onFormActionSubmit.bind(this)\n                            );\n                    } else if ($el.is(\".pat-subform\")) {\n                        log.debug(\"Initializing subform with injection\");\n                    } else {\n                        $el.on(\"click.pat-inject\", this.onTrigger.bind(this));\n                    }\n                    break;\n                case \"autoload\":\n                    if (!cfgs[0].delay) {\n                        this.onTrigger({ currentTarget: $el[0] });\n                    } else {\n                        // generate UID\n                        const uid = Math.random().toString(36);\n                        $el.attr(\"data-pat-inject-uid\", uid);\n\n                        // function to trigger the autoload and mark as triggered\n                        const delayed_trigger = (uid_) => {\n                            // Check if the element has been removed from the dom\n                            const still_there = $(\n                                \"[data-pat-inject-uid='\" + uid_ + \"']\"\n                            );\n                            if (still_there.length == 0) return false;\n\n                            $el.data(\"pat-inject-autoloaded\", true);\n                            this.onTrigger({ currentTarget: $el[0] });\n                            return true;\n                        };\n                        window.setTimeout(\n                            delayed_trigger.bind(null, uid),\n                            cfgs[0].delay\n                        );\n                    }\n                    break;\n                case \"autoload-visible\":\n                    this._initAutoloadVisible($el, cfgs);\n                    break;\n                case \"idle\":\n                    this._initIdleTrigger($el, cfgs[0].delay);\n                    break;\n            }\n        }\n\n        log.debug(\"initialised:\", $el);\n        return $el;\n    },\n\n    destroy($el) {\n        $el.off(\".pat-inject\");\n        $el.data(\"pat-inject\", null);\n        return $el;\n    },\n\n    onTrigger(e) {\n        /* Injection has been triggered, either via form submission or a\n         * link has been clicked.\n         */\n        const $el = $(e.currentTarget);\n        const cfgs = $el.data(\"pat-inject\");\n        if ($el.is(\"form\")) {\n            $(cfgs).each((i, v) => {\n                v.params = $.param($el.serializeArray());\n            });\n        }\n        e.preventDefault && e.preventDefault();\n        $el.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $el);\n    },\n\n    onFormActionSubmit(e) {\n        ajax.onClickSubmit(e); // make sure the submitting button is sent with the form\n\n        const $button = $(e.target);\n        const formaction = $button.attr(\"formaction\");\n        const $form = $button.parents(\".pat-inject\").first();\n        const opts = {\n            url: formaction,\n        };\n        const $cfg_node = $button.closest(\"[data-pat-inject]\");\n        const cfgs = this.extractConfig($cfg_node, opts);\n\n        $(cfgs).each((i, v) => {\n            v.params = $.param($form.serializeArray());\n        });\n\n        e.preventDefault();\n        $form.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $form);\n    },\n\n    submitSubform($sub) {\n        /* This method is called from pat-subform\n         */\n        const $el = $sub.parents(\"form\");\n        const cfgs = $sub.data(\"pat-inject\");\n\n        // store the params of the subform in the config, to be used by history\n        $(cfgs).each((i, v) => {\n            v.params = $.param($sub.serializeArray());\n        });\n\n        try {\n            $el.trigger(\"patterns-inject-triggered\");\n        } catch (e) {\n            log.error(\"patterns-inject-triggered\", e);\n        }\n        this.execute(cfgs, $el);\n    },\n\n    extractConfig($el, opts) {\n        opts = $.extend({}, opts);\n\n        const cfgs = parser.parse($el, opts, true);\n        cfgs.forEach((cfg) => {\n            cfg.$context = $el;\n            // opts and cfg have priority, fall back to href/action\n            cfg.url =\n                opts.url ||\n                cfg.url ||\n                $el.attr(\"href\") ||\n                $el.attr(\"action\") ||\n                $el.parents(\"form\").attr(\"action\") ||\n                \"\";\n\n            // separate selector from url\n            const urlparts = cfg.url.split(\"#\");\n            cfg.url = urlparts[0];\n\n            if (urlparts.length > 2) {\n                log.warn(\"Ignoring additional source ids:\", urlparts.slice(2));\n            }\n\n            if (!cfg.defaultSelector) {\n                // if no selector, check for selector as part of original url\n                cfg.defaultSelector = (urlparts[1] && \"#\" + urlparts[1]) || \"body\";\n            }\n            if (cfg.delay) {\n                try {\n                    cfg.delay = utils.parseTime(cfg.delay);\n                } catch (e) {\n                    log.warn(\"Invalid delay value: \", cfg.delay);\n                    cfg.delay = null;\n                }\n            }\n            cfg.processDelay = 0;\n        });\n        return cfgs;\n    },\n\n    elementIsDirty(m) {\n        /* Check whether the passed in form element contains a value.\n         */\n        const data = $.map(m.find(\":input:not(select)\"), (i) => {\n            const val = $(i).val();\n            return Boolean(val) && val !== $(i).attr(\"placeholder\");\n        });\n        return $.inArray(true, data) !== -1;\n    },\n\n    askForConfirmation(cfgs) {\n        /* If configured to do so, show a confirmation dialog to the user.\n         * This is done before attempting to perform injection.\n         */\n        let should_confirm = false;\n        let message;\n\n        for (const cfg of cfgs) {\n            let _confirm = false;\n            if (cfg.confirm == \"always\") {\n                _confirm = true;\n            } else if (cfg.confirm === \"form-data\") {\n                if (cfg.target != \"none\") _confirm = this.elementIsDirty(cfg.$target);\n            } else if (cfg.confirm === \"class\") {\n                if (cfg.target != \"none\") _confirm = cfg.$target.hasClass(\"is-dirty\");\n            }\n            if (_confirm) {\n                should_confirm = true;\n                message = cfg.confirmMessage;\n            }\n        }\n        if (should_confirm) {\n            if (!window.confirm(message)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    ensureTarget(cfg) {\n        /* Make sure that a target element exists and that it's assigned to\n         * cfg.$target.\n         */\n        // make sure target exist\n        if (cfg.target === \"none\") {\n            // special case, we don't want to inject anything\n            return true;\n        }\n        cfg.$target =\n            cfg.$target || (cfg.target === \"self\" ? cfg.$context : $(cfg.target));\n        if (cfg.$target.length === 0) {\n            if (!cfg.target) {\n                log.error(\"Need target selector\", cfg);\n                return false;\n            }\n            cfg.$target = this.createTarget(cfg.target);\n            cfg.$injected = cfg.$target;\n        }\n        return true;\n    },\n\n    verifySingleConfig(url, cfg) {\n        /* Verify one of potentially multiple configs (i.e. argument lists).\n         *\n         * Extract modifiers such as ::element or ::after.\n         * Ensure that a target element exists.\n         */\n        if (cfg.url !== url) {\n            // in case of multi-injection, all injections need to use\n            // the same url\n            log.error(\"Unsupported different urls for multi-inject\");\n            return false;\n        }\n        // defaults\n        cfg.source = cfg.source || cfg.defaultSelector;\n        cfg.target = cfg.target || cfg.defaultSelector;\n\n        if (!this.extractModifiers(cfg)) {\n            return false;\n        }\n        if (!this.ensureTarget(cfg)) {\n            return false;\n        }\n        this.listenForFormReset(cfg);\n        return true;\n    },\n\n    verifyConfig(cfgs) {\n        /* Verify and post-process all the configurations.\n         * Each \"config\" is an arguments list separated by the &&\n         * combination operator.\n         *\n         * In case of multi-injection, only one URL is allowed, which\n         * should be specified in the first config (i.e. arguments list).\n         *\n         * Verification for each cfg in the array needs to succeed.\n         */\n        return cfgs.every((cfg) => this.verifySingleConfig(cfgs[0].url, cfg));\n    },\n\n    listenForFormReset(cfg) {\n        /* if pat-inject is used to populate target in some form and when\n         * Cancel button is pressed (this triggers reset event on the\n         * form) you would expect to populate with initial placeholder\n         */\n        if (cfg.target === \"none\")\n            // Special case, we don't want to display any return value.\n            return;\n        const $form = cfg.$target.parents(\"form\");\n        if ($form.length !== 0 && cfg.$target.data(\"initial-value\") === undefined) {\n            cfg.$target.data(\"initial-value\", cfg.$target.html());\n            $form.on(\"reset\", () => {\n                cfg.$target.html(cfg.$target.data(\"initial-value\"));\n            });\n        }\n    },\n\n    extractModifiers(cfg) {\n        /* The user can add modifiers to the source and target arguments.\n         * Modifiers such as ::element, ::before and ::after.\n         * We identifiy and extract these modifiers here.\n         */\n        const source_re = /^(.*?)(::element)?$/;\n        const target_re = /^(.*?)(::element)?(::after|::before)?$/;\n        const source_match = source_re.exec(cfg.source);\n        const target_match = target_re.exec(cfg.target);\n\n        cfg.source = source_match[1];\n        cfg.sourceMod = source_match[2] ? \"element\" : \"content\";\n        cfg.target = target_match[1];\n        const targetMod = target_match[2] ? \"element\" : \"content\";\n        const targetPosition = (target_match[3] || \"::\").slice(2); // position relative to target\n\n        if (cfg.loadingClass) {\n            cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetMod;\n            if (targetPosition && cfg.loadingClass) {\n                cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetPosition;\n            }\n        }\n        cfg.action = targetMod + targetPosition;\n        // Once we start detecting illegal combinations, we'll\n        // return false in case of error\n        return true;\n    },\n\n    createTarget(selector) {\n        /* create a target that matches the selector\n         *\n         * XXX: so far we only support #target and create a div with\n         * that id appended to the body.\n         */\n        if (selector.slice(0, 1) !== \"#\") {\n            log.error(\"only id supported for non-existing target\");\n            return null;\n        }\n        const $target = $(\"<div />\").attr({ id: selector.slice(1) });\n        $(\"body\").append($target);\n        return $target;\n    },\n\n    stopBubblingFromRemovedElement($el, cfgs, ev) {\n        /* IE8 fix. Stop event from propagating IF $el will be removed\n         * from the DOM. With pat-inject, often $el is the target that\n         * will itself be replaced with injected content.\n         *\n         * IE8 cannot handle events bubbling up from an element removed\n         * from the DOM.\n         *\n         * See: http://stackoverflow.com/questions/7114368/why-is-jquery-remove-throwing-attr-exception-in-ie8\n         */\n        for (const cfg of cfgs) {\n            const sel = cfg.target;\n            if ($el.parents(sel).addBack(sel) && !ev.isPropagationStopped()) {\n                ev.stopPropagation();\n                return;\n            }\n        }\n    },\n\n    _performInjection(target, $el, $source, cfg, trigger, title) {\n        /* Called after the XHR has succeeded and we have a new $source\n         * element to inject.\n         */\n        if (cfg.sourceMod === \"content\") {\n            $source = $source.contents();\n        }\n        let $src;\n        // $source.clone() does not work with shived elements in IE8\n        if (document.all && document.querySelector && !document.addEventListener) {\n            $src = $source.map((idx, el) => $(el.outerHTML)[0]);\n        } else {\n            $src = $source.safeClone();\n        }\n\n        $src.findInclusive(\"img\").on(\"load\", (e) => {\n            $(e.currentTarget).trigger(\"pat-inject-content-loaded\");\n        });\n\n        const $injected = cfg.$injected || $src;\n        // Now the injection actually happens.\n        if (this._inject(trigger, $src, $(target), cfg)) {\n            this._afterInjection($el, $injected, cfg);\n        }\n        // History support. if subform is submitted, append form params\n        const glue = cfg.url.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n        if (cfg.history === \"record\" && \"pushState\" in history) {\n            if (cfg.params) {\n                history.pushState(\n                    { url: cfg.url + glue + cfg.params },\n                    \"\",\n                    cfg.url + glue + cfg.params\n                );\n            } else {\n                history.pushState({ url: cfg.url }, \"\", cfg.url);\n            }\n            // Also inject title element if we have one\n            if (title)\n                this._inject(trigger, title, $(\"title\"), {\n                    action: \"element\",\n                });\n        }\n    },\n\n    _afterInjection($el, $injected, cfg) {\n        /* Set a class on the injected elements and fire the\n         * patterns-injected event.\n         */\n        $injected\n            .filter((idx, el_) => {\n                // setting data on textnode fails in IE8\n                return el_.nodeType !== TEXT_NODE;\n            })\n            .data(\"pat-injected\", { origin: cfg.url });\n\n        if ($injected.length === 1 && $injected[0].nodeType == TEXT_NODE) {\n            // Only one element injected, and it was a text node.\n            // So we trigger \"patterns-injected\" on the parent.\n            // The event handler should check whether the\n            // injected element and the triggered element are\n            // the same.\n            $injected.parent().trigger(\"patterns-injected\", [cfg, $el[0], $injected[0]]);\n        } else {\n            $injected.each((idx, el_) => {\n                // patterns-injected event will be triggered for each injected (non-text) element.\n                if (el_.nodeType !== TEXT_NODE) {\n                    $(el_)\n                        .addClass(cfg[\"class\"])\n                        .trigger(\"patterns-injected\", [cfg, $el[0], el_]);\n                }\n            });\n        }\n\n        if (cfg.scroll && cfg.scroll !== \"none\") {\n            let scroll_container = cfg.$target.parents().addBack().filter(\":scrollable\");\n            scroll_container = scroll_container.length ? scroll_container[0] : window;\n\n            // default for scroll===top\n            let top = 0;\n            let left = 0;\n\n            if (cfg.scroll !== \"top\") {\n                const scroll_target =\n                    cfg.scroll === \"target\"\n                        ? cfg.$target[0]\n                        : $injected.filter(cfg.scroll)[0];\n\n                // Get the reference element to which against we calculate\n                // the relative position of the target.\n                // In case of a scroll container of window, we do not have\n                // getBoundingClientRect method, so get the body instead.\n                const scroll_container_ref =\n                    scroll_container === window ? document.body : scroll_container;\n\n                // Calculate absolute [Â¹] position difference between\n                // scroll_container and scroll_target.\n                // Substract the container's border from the scrolling\n                // value, as this one isn't respected by\n                // getBoundingClientRect [Â²] and would lead to covered\n                // items [Â³].\n                // Â¹) so that it doesn't make a difference, if the element\n                // is below or above the scrolling container. We just need\n                // to know the absolute difference.\n                // Â²) Calculations are based from the viewport.\n                // Â³) See:\n                //      https://docs.microsoft.com/en-us/previous-versions//hh781509(v=vs.85)\n                //      https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n                left = Math.abs(\n                    scroll_target.getBoundingClientRect().left +\n                        scroll_container_ref.scrollLeft -\n                        scroll_container_ref.getBoundingClientRect().left -\n                        dom.get_css_value(\n                            scroll_container_ref,\n                            \"border-left-width\",\n                            true\n                        )\n                );\n                top = Math.abs(\n                    scroll_target.getBoundingClientRect().top +\n                        scroll_container_ref.scrollTop -\n                        scroll_container_ref.getBoundingClientRect().top -\n                        dom.get_css_value(scroll_container_ref, \"border-top-width\", true)\n                );\n            }\n            if (scroll_container === window) {\n                scroll_container.scrollTo(left, top);\n            } else {\n                scroll_container.scrollLeft = left;\n                scroll_container.scrollTop = top;\n            }\n        }\n\n        $el[0].dispatchEvent(\n            new Event(\"pat-inject-success\", { bubbles: true, cancelable: true })\n        );\n    },\n\n    async _onInjectSuccess($el, cfgs, ev) {\n        let data = ev && ev.jqxhr && ev.jqxhr.responseText;\n        if (!data) {\n            log.warn(\"No response content, aborting\", ev);\n            return;\n        }\n        if (cfgs[0].source === \"none\") {\n            // Special case, we want to call something, but we don't want to inject anything\n            data = \"\";\n        }\n        $.each(cfgs[0].hooks || [], (idx, hook) =>\n            $el.trigger(\"pat-inject-hook-\" + hook)\n        );\n        this.stopBubblingFromRemovedElement($el, cfgs, ev);\n        const sources$ = await this.callTypeHandler(cfgs[0].dataType, \"sources\", $el, [\n            cfgs,\n            data,\n            ev,\n        ]);\n        /* pick the title source for dedicated handling later\n          Title - if present - is always appended at the end. */\n        let title;\n        if (\n            sources$ &&\n            sources$[sources$.length - 1] &&\n            sources$[sources$.length - 1][0] &&\n            sources$[sources$.length - 1][0].nodeName == \"TITLE\"\n        ) {\n            title = sources$[sources$.length - 1];\n        }\n        cfgs.forEach((cfg, idx1) => {\n            const perform_inject = () => {\n                if (cfg.target != \"none\")\n                    cfg.$target.each((idx2, target) => {\n                        this._performInjection(\n                            target,\n                            $el,\n                            sources$[idx1],\n                            cfg,\n                            ev.target,\n                            title\n                        );\n                    });\n            };\n            if (cfg.processDelay) {\n                setTimeout(() => perform_inject(), cfg.processDelay);\n            } else {\n                perform_inject();\n            }\n        });\n        if (cfgs[0].nextHref && $el.is(\"a\")) {\n            // In case next-href is specified the anchor's href will\n            // be set to it after the injection is triggered.\n            $el.attr({ href: cfgs[0].nextHref.replace(/&amp;/g, \"&\") });\n            this.destroy($el);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n    },\n\n    async _onInjectError($el, cfgs, event) {\n        let explanation = \"\";\n        const status = event.jqxhr.status;\n        const timestamp = new Date();\n        if (status % 100 == 4) {\n            explanation =\n                \"Sorry! We couldn't find the page to load. Please make a screenshot and send it to support. Thank you!\";\n        } else if (status % 100 == 5) {\n            explanation =\n                \"I am very sorry! There was an error at the server. Please make a screenshot and contact support. Thank you!\";\n        } else if (status == 0) {\n            explanation =\n                \"It seems, the server is down. Please make a screenshot and contact support. Thank you!\";\n        }\n\n        let error_page;\n        let error_page_fragment;\n        const url_params = new URLSearchParams(window.location.search);\n        if (url_params.get(\"pat-inject-errorhandler.off\") === null) {\n            // Prepare a error page to be injected into the document.\n\n            // Try to get a suitable error message from pre-configured error pages.\n            const error_page_url = document\n                .querySelector(`meta[name^=pat-inject-status-${status}]`)\n                ?.getAttribute(\"content\", false);\n            error_page_fragment = error_page_url?.split(\"#\")[1];\n            error_page_fragment = error_page_fragment ? `#${error_page_fragment}` : null;\n\n            if (error_page_fragment) {\n                error_page = document.createElement(\"html\");\n                error_page.innerHTML = event.jqxhr.responseText;\n                error_page = error_page.querySelector(error_page_fragment);\n            }\n\n            if (!error_page && error_page_url) {\n                try {\n                    const error_page_response = await fetch(error_page_url, {\n                        method: \"GET\",\n                    });\n                    error_page = document.createElement(\"html\");\n                    error_page.innerHTML = await error_page_response.text();\n                    error_page = error_page.querySelector(error_page_fragment || \"body\");\n                } catch {\n                    // fall back to standard error message and ignore.\n                }\n            }\n        }\n\n        // clean up\n        cfgs.forEach((cfg) => {\n            if (\"$injected\" in cfg) {\n                cfg.$injected.remove();\n            }\n            cfg.$target.removeClass(cfg.loadingClass);\n            $el.removeClass(cfg.executingClass);\n        });\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n\n        if (error_page) {\n            const error_zone = document.querySelector(error_page_fragment || \"body\");\n            error_zone.innerHTML = error_page.innerHTML;\n            registry.scan(error_zone); // initialize any patterns in error page\n        } else {\n            const msg_attr = `${explanation} Status is ${status} ${event.jqxhr.statusText}, time was ${timestamp}. You can click to close this.`;\n            $(\"body\").attr(\"data-error-message\", msg_attr);\n            $(\"body\").on(\"click\", () => {\n                $(\"body\").removeAttr(\"data-error-message\");\n                window.location.href = window.location.href; // reload\n            });\n        }\n    },\n\n    execute(cfgs, $el) {\n        /* Actually execute the injection.\n         *\n         * Either by making an ajax request or by spoofing an ajax\n         * request when the content is readily available in the current page.\n         */\n        // get a kinda deep copy, we scribble on it\n        cfgs = cfgs.map((cfg) => $.extend({}, cfg));\n        if (!this.verifyConfig(cfgs)) {\n            return;\n        }\n        if (!this.askForConfirmation(cfgs)) {\n            return;\n        }\n        if ($el.data(\"pat-inject-triggered\")) {\n            // Prevent double triggers;\n            return;\n        }\n        $el.data(\"pat-inject-triggered\", true);\n        // possibility for spinners on targets\n        cfgs.filter((cfg) => cfg?.loadingClass).forEach((cfg) => {\n            if (cfg.target != \"none\") {\n                cfg.$target.addClass(cfg.loadingClass);\n            }\n        });\n        // Put the execute class on the elem that has pat inject on it\n        cfgs.filter((cfg) => cfg?.executingClass).forEach((cfg) =>\n            $el.addClass(cfg.executingClass)\n        );\n\n        $el.on(\n            \"pat-ajax-success.pat-inject\",\n            this._onInjectSuccess.bind(this, $el, cfgs)\n        );\n        $el.on(\"pat-ajax-error.pat-inject\", this._onInjectError.bind(this, $el, cfgs));\n        $el.on(\"pat-ajax-success.pat-inject pat-ajax-error.pat-inject\", () =>\n            $el.removeData(\"pat-inject-triggered\")\n        );\n\n        if (cfgs[0].url.length) {\n            ajax.request($el, {\n                \"url\": cfgs[0].url,\n                \"browser-cache\": cfgs[0].browserCache,\n            });\n        } else {\n            // If there is no url specified, then content is being fetched\n            // from the same page.\n            // No need to do an ajax request for this, so we spoof the ajax\n            // event.\n            $el.trigger({\n                type: \"pat-ajax-success\",\n                jqxhr: {\n                    responseText: $(\"body\").html(),\n                },\n            });\n        }\n    },\n\n    _inject(trigger, $source, $target, cfg) {\n        // action to jquery method mapping, except for \"content\"\n        // and \"element\"\n        const method = {\n            contentbefore: \"prepend\",\n            contentafter: \"append\",\n            elementbefore: \"before\",\n            elementafter: \"after\",\n        }[cfg.action];\n\n        if (cfg.source === \"none\") {\n            $target.replaceWith(\"\");\n            return true;\n        }\n        if ($source.length === 0) {\n            log.warn(\"Aborting injection, source not found:\", $source);\n            $(trigger).trigger(\"pat-inject-missingSource\", {\n                url: cfg.url,\n                selector: cfg.source,\n            });\n            return false;\n        }\n        if (cfg.target === \"none\")\n            // Special case. Don't do anything, we don't want any result\n            return true;\n        if ($target.length === 0) {\n            log.warn(\"Aborting injection, target not found:\", $target);\n            $(trigger).trigger(\"pat-inject-missingTarget\", {\n                selector: cfg.target,\n            });\n            return false;\n        }\n        if (cfg.action === \"content\") {\n            $target.empty().append($source);\n        } else if (cfg.action === \"element\") {\n            $target.replaceWith($source);\n        } else {\n            $target[method]($source);\n        }\n        return true;\n    },\n\n    _sourcesFromHtml(html, url, sources) {\n        const $html = this._parseRawHtml(html, url);\n        return sources.map((source) => {\n            if (source === \"body\") {\n                source = \"#__original_body\";\n            }\n            if (source === \"none\") {\n                return $(\"<!-- -->\");\n            }\n            const $source = $html.find(source);\n\n            if ($source.length === 0) {\n                if (source != \"title\") {\n                    log.warn(\"No source elements for selector:\", source, $html);\n                }\n            }\n\n            $source.find('a[href^=\"#\"]').each((idx, el_) => {\n                const href = el_.getAttribute(\"href\");\n                if (href.indexOf(\"#{1}\") !== -1) {\n                    // We ignore hrefs containing #{1} because they're not\n                    // valid and only applicable in the context of\n                    // pat-clone.\n                    return;\n                }\n                // Skip in-document links pointing to an id that is inside\n                // this fragment.\n                if (href.length === 1) {\n                    // Special case for top-of-page links\n                    el_.href = url;\n                } else if (!$source.find(href).length) {\n                    el_.href = url + href;\n                }\n            });\n            return $source;\n        });\n    },\n\n    _rebaseAttrs: {\n        A: \"href\",\n        FORM: \"action\",\n        IMG: \"data-pat-inject-rebase-src\",\n        OBJECT: \"data\",\n        SOURCE: \"data-pat-inject-rebase-src\",\n        VIDEO: \"data-pat-inject-rebase-src\",\n    },\n\n    _rebaseOptions: {\n        \"calendar\": [\"url\", \"event-sources\"],\n        \"collapsible\": [\"load-content\"],\n        \"date-picker\": [\"i18n\"],\n        \"datetime-picker\": [\"i18n\"],\n        \"inject\": [\"url\"],\n    },\n\n    _rebaseHTML(base, html) {\n        if (html === \"\") {\n            // Special case, source is none\n            return \"\";\n        }\n        const $page = $(\n            html.replace(/(\\s)(src\\s*)=/gi, '$1src=\"\" data-pat-inject-rebase-$2=').trim()\n        )\n            .wrapAll(\"<div>\")\n            .parent();\n\n        $page.find(Object.keys(this._rebaseAttrs).join(\",\")).each((idx, el_) => {\n            const $el_ = $(el_);\n            const attrName = this._rebaseAttrs[el_.tagName];\n            let value = $el_.attr(attrName);\n\n            if (\n                value &&\n                value.slice(0, 2) !== \"@@\" &&\n                value[0] !== \"#\" &&\n                value.slice(0, 7) !== \"mailto:\" &&\n                value.slice(0, 4) !== \"tel:\" &&\n                value.slice(0, 4) !== \"fax:\" &&\n                value.slice(0, 7) !== \"callto:\" &&\n                value.slice(0, 10) !== \"ts3server:\" &&\n                value.slice(0, 6) !== \"teams:\" &&\n                value.slice(0, 11) !== \"javascript:\"\n            ) {\n                value = utils.rebaseURL(base, value);\n                $el_.attr(attrName, value);\n            }\n        });\n\n        for (const [pattern_name, opts] of Object.entries(this._rebaseOptions)) {\n            for (const el_ of dom.querySelectorAllAndMe(\n                $page[0],\n                `[data-pat-${pattern_name}]`\n            )) {\n                const pattern = registry.patterns?.[pattern_name];\n                const pattern_parser = pattern?.parser;\n                if (!pattern_parser) {\n                    continue;\n                }\n                // parse: no default options, possibly multiple configs, no grouping.\n                const options = pattern_parser.parse(el_, {}, true, false, false);\n                let changed = false;\n                for (const config of options) {\n                    for (const opt of opts) {\n                        const val = config[opt];\n                        if (!val) {\n                            continue;\n                        }\n                        changed = true;\n                        if (Array.isArray(val)) {\n                            config[opt] = val.map((it) => utils.rebaseURL(base, it));\n                        } else {\n                            config[opt] = utils.rebaseURL(base, val);\n                        }\n                    }\n                }\n                if (changed) {\n                    el_.setAttribute(\n                        `data-pat-${pattern_name}`,\n                        JSON.stringify(options.length === 1 ? options[0] : options)\n                    );\n                }\n            }\n        }\n\n        // XXX: IE8 changes the order of attributes in html. The following\n        // lines move data-pat-inject-rebase-src to src.\n        $page.find(\"[data-pat-inject-rebase-src]\").each((id, el_) => {\n            const $el = $(el_);\n            $el.attr(\"src\", $el.attr(\"data-pat-inject-rebase-src\")).removeAttr(\n                \"data-pat-inject-rebase-src\"\n            );\n        });\n\n        return $page\n            .html()\n            .replace(/src=\"\" data-pat-inject-rebase-/g, \"\")\n            .trim();\n    },\n\n    _parseRawHtml(html, url) {\n        url = url || \"\";\n\n        // remove script tags and head and replace body by a div\n        const title = html.match(/\\<title\\>(.*)\\<\\/title\\>/);\n        let clean_html = html\n            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n            .replace(/<head\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/head>/gi, \"\")\n            .replace(/<body([^>]*?)>/gi, '<div id=\"__original_body\">')\n            .replace(/<\\/body([^>]*?)>/gi, \"</div>\");\n        if (title && title.length == 2) {\n            clean_html = title[0] + clean_html;\n        }\n        try {\n            clean_html = this._rebaseHTML(url, clean_html);\n        } catch (e) {\n            log.error(\"Error rebasing urls\", e);\n        }\n        const $html = $(\"<div/>\").html(clean_html);\n        if ($html.children().length === 0) {\n            log.warn(\"Parsing html resulted in empty jquery object:\", clean_html);\n        }\n        return $html;\n    },\n\n    _initAutoloadVisible($el, cfgs) {\n        if ($el.data(\"pat-inject-autoloaded\")) {\n            // ignore executed autoloads\n            return false;\n        }\n\n        const el = $el[0];\n\n        // delay: default is 200ms to allow scrolling over and past autoload-visible elements without loading them.\n        const delay = cfgs[0].delay || 200;\n        log.debug(`Delay time: ${delay}`);\n\n        // function to trigger the autoload and mark as triggered\n        const trigger = (event) => {\n            if ($el.data(\"pat-inject-autoloaded\")) {\n                log.debug(`autoload-visible trigger skipped ${el}`);\n                return false;\n            }\n            $el.data(\"pat-inject-autoloaded\", true);\n            this.onTrigger({ currentTarget: el });\n            event && event.preventDefault();\n            log.debug(`autoload-visible trigger run ${el}`);\n            return true;\n        };\n\n        // Config see: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n        const intersection_observer_config = {\n            threshold: 0, // If even one pixel is visible, the callback will be run.\n            root: null, // Root is browser viewport. If the element is visible to the user, the callback will be run.\n            margin: \"0px\", // No margins. The element is not preloaded.\n        };\n\n        let timeout_id = null;\n        const observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting) {\n                    // Run the callback after 200ms to prevent loading all\n                    // visible elements when scrolling over.\n                    timeout_id = window.setTimeout(() => {\n                        observer.disconnect(); // Stop observing loaded elements.\n                        trigger();\n                    }, delay);\n                    log.debug(`autoload-visible intersecting ${el}`);\n                } else {\n                    window.clearTimeout(timeout_id);\n                    log.debug(`autoload-visible not intersecting ${el}`);\n                }\n            }\n        }, intersection_observer_config);\n        observer.observe(el);\n    },\n\n    _initIdleTrigger($el, delay) {\n        // XXX TODO: handle item removed from DOM\n        const timeout = parseInt(delay, 10);\n        let timer;\n\n        const onTimeout = () => {\n            this.onTrigger({ currentTarget: $el[0] });\n            unsub();\n            clearTimeout(timer);\n        };\n\n        const onInteraction = utils.debounce(() => {\n            if (!document.body.contains($el[0])) {\n                unsub();\n                return;\n            }\n            clearTimeout(timer);\n            timer = setTimeout(onTimeout, timeout);\n        }, timeout);\n\n        const unsub = () => {\n            [\"scroll\", \"resize\"].forEach((e) =>\n                window.removeEventListener(e, onInteraction)\n            );\n            [\n                \"click\",\n                \"keypress\",\n                \"keyup\",\n                \"mousemove\",\n                \"touchstart\",\n                \"touchend\",\n            ].forEach((e) => document.removeEventListener(e, onInteraction));\n        };\n\n        onInteraction();\n\n        [\"scroll\", \"resize\"].forEach((e) => window.addEventListener(e, onInteraction));\n        [\"click\", \"keypress\", \"keyup\", \"mousemove\", \"touchstart\", \"touchend\"].forEach(\n            (e) => document.addEventListener(e, onInteraction)\n        );\n    },\n\n    // XXX: simple so far to see what the team thinks of the idea\n    registerTypeHandler(type, handler) {\n        this.handlers[type] = handler;\n    },\n\n    async callTypeHandler(type, fn, context, params) {\n        type = type || \"html\";\n        if (this.handlers[type] && $.isFunction(this.handlers[type][fn])) {\n            return await this.handlers[type][fn].bind(this)(...params);\n        } else {\n            return null;\n        }\n    },\n\n    handlers: {\n        html: {\n            sources(cfgs, data) {\n                const sources = cfgs.map((cfg) => cfg.source);\n                sources.push(\"title\");\n                return this._sourcesFromHtml(data, cfgs[0].url, sources);\n            },\n        },\n    },\n};\n\n$(document).on(\"patterns-injected.inject\", (ev, cfg, trigger, injected) => {\n    /* Listen for the patterns-injected event.\n     *\n     * Remove the \"loading-class\" classes from all injection targets and\n     * then scan the injected content for new patterns.\n     */\n    if (cfg && cfg.skipPatInjectHandler) {\n        // Allow skipping this handler but still have other handlers in other\n        // patterns listen to ``patterns-injected``.\n        return;\n    }\n    if (cfg) {\n        cfg.$target.removeClass(cfg.loadingClass);\n        // Remove the executing class, add the executed class to the element with pat.inject on it.\n        $(trigger).removeClass(cfg.executingClass).addClass(cfg.executedClass);\n    }\n    if (injected.nodeType !== TEXT_NODE && injected !== COMMENT_NODE) {\n        registry.scan(injected, null, { type: \"injection\", element: trigger });\n        $(injected).trigger(\"patterns-injected-scanned\");\n    }\n});\n\n$(window).on(\"popstate\", (event) => {\n    // popstate also triggers on traditional anchors\n    if (!event.originalEvent.state && \"replaceState\" in history) {\n        try {\n            history.replaceState(\"anchor\", \"\", document.location.href);\n        } catch (e) {\n            log.debug(e);\n        }\n        return;\n    }\n    // Not only change the URL, also reload the page.\n    window.location.reload();\n});\n\n// this entry ensures that the initally loaded page can be reached with\n// the back button\nif (\"replaceState\" in history) {\n    try {\n        history.replaceState(\"pageload\", \"\", document.location.href);\n    } catch (e) {\n        log.debug(e);\n    }\n}\n\nregistry.register(inject);\nexport default inject;\n","import \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["methods","init","options","settings","time","initialTime","exceptionAreas","this","each","$this","data","lastEvent","Date","trueTime","untouched","inExceptionArea","on","mouseMoved","find","live","parent","enteredException","leftException","timeout","addClass","event","trigger","destroy","window","off","remove","removeData","hasClass","removeClass","startTimer","fn","setTimeout","Math","floor","now","diff","method","apply","Array","prototype","slice","call","arguments","scrollable","element","css","clientHeight","scrollHeight","clientWidth","scrollWidth","parent_id","absoluteParent","parents","length","elemTop","position","top","elemBottom","height","viewTop","scrollTop","viewBottom","docElem","elem","origin","left","nodeType","ownerDocument","document","documentElement","offsettop","offsetleft","thiswidth","width","pos","safeOffset","setleft","settop","appendTo","show","selector","$ancestor","closest","$child","childMarginEdgeLeft","parseInt","childMarginEdgeTop","ancestorPaddingEdgeLeft","ancestorPaddingEdgeTop","addBack","filter","speed","easing","callback","animate","a","i","m","text","toUpperCase","indexOf","log","logging","addArgument","$el","is","attr","split","xhrCount","undefined","get","_","name","parser","onTriggerEvents","onClickSubmit","warn","el","target","form","value","preventDefault","request","opts","_request","cfg","parse","seqNumber","inc","url","temp","clickedData","args","context","serialize","Boolean","join","headers","cache","browserCache","accept","Accept","formdata","FormData","key","append","debug","ajax_deferred","done","status","jqxhr","type","fail","error","registry","inject","cfgs","extractConfig","some","e","history","nextHref","href","location","pushMarker","onTrigger","currentTarget","idleTrigger","_initIdleTrigger","forEach","delay","processDelay","bind","ajax","onFormActionSubmit","uid","random","toString","delayed_trigger","uid_","_initAutoloadVisible","v","params","serializeArray","execute","$button","formaction","$form","first","$cfg_node","submitSubform","$sub","$context","urlparts","defaultSelector","utils","elementIsDirty","val","askForConfirmation","message","should_confirm","_confirm","confirm","$target","confirmMessage","ensureTarget","createTarget","$injected","verifySingleConfig","source","extractModifiers","listenForFormReset","verifyConfig","every","html","source_match","exec","target_match","sourceMod","targetMod","targetPosition","loadingClass","action","id","stopBubblingFromRemovedElement","ev","sel","isPropagationStopped","stopPropagation","_performInjection","$source","title","$src","contents","all","querySelector","addEventListener","map","idx","outerHTML","safeClone","findInclusive","_inject","_afterInjection","glue","pushState","el_","scroll","scroll_container","scroll_target","scroll_container_ref","body","abs","getBoundingClientRect","scrollLeft","dom","scrollTo","dispatchEvent","Event","bubbles","cancelable","async","responseText","hooks","hook","sources$","callTypeHandler","dataType","nodeName","idx1","perform_inject","idx2","replace","explanation","timestamp","error_page","error_page_fragment","URLSearchParams","search","error_page_url","getAttribute","createElement","innerHTML","error_page_response","fetch","executingClass","error_zone","msg_attr","statusText","removeAttr","_onInjectSuccess","_onInjectError","contentbefore","contentafter","elementbefore","elementafter","replaceWith","empty","_sourcesFromHtml","sources","$html","_parseRawHtml","_rebaseAttrs","A","FORM","IMG","OBJECT","SOURCE","VIDEO","_rebaseOptions","_rebaseHTML","base","$page","trim","wrapAll","Object","keys","$el_","attrName","tagName","pattern_name","entries","pattern","pattern_parser","changed","config","opt","isArray","it","setAttribute","JSON","stringify","match","clean_html","children","timeout_id","observer","IntersectionObserver","entry","isIntersecting","disconnect","clearTimeout","threshold","root","margin","observe","timer","onTimeout","unsub","onInteraction","contains","removeEventListener","registerTypeHandler","handler","handlers","push","injected","skipPatInjectHandler","executedClass","originalEvent","state","reload","replaceState","is_markdown_resource","Markdown","render","replaceAll","Showdown","default","extensions","prettify","pre","$rendering","converter","Converter","tables","makeHtml","header","extractSection","level","matcher","RegExp","ready","test","Promise","pat","renderForInjection"],"sourceRoot":""}