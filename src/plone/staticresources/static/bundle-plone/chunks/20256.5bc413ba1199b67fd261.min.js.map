{"version":3,"file":"chunks/20256.5bc413ba1199b67fd261.min.js","mappings":"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","sources":["webpack://plone.staticresources/./node_modules/codejar/codejar.js"],"sourcesContent":["const globalWindow = window;\nexport function CodeJar(editor, highlight, opt = {}) {\n    const options = Object.assign({ tab: '\\t', indentOn: /{$/, spellcheck: false, catchTab: true, preserveIdent: true, addClosing: true, history: true, window: globalWindow }, opt);\n    const window = options.window;\n    const document = window.document;\n    let listeners = [];\n    let history = [];\n    let at = -1;\n    let focus = false;\n    let callback;\n    let prev; // code content prior keydown event\n    editor.setAttribute('contenteditable', 'plaintext-only');\n    editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\n    editor.style.outline = 'none';\n    editor.style.overflowWrap = 'break-word';\n    editor.style.overflowY = 'auto';\n    editor.style.whiteSpace = 'pre-wrap';\n    let isLegacy = false; // true if plaintext-only is not supported\n    highlight(editor);\n    if (editor.contentEditable !== 'plaintext-only')\n        isLegacy = true;\n    if (isLegacy)\n        editor.setAttribute('contenteditable', 'true');\n    const debounceHighlight = debounce(() => {\n        const pos = save();\n        highlight(editor, pos);\n        restore(pos);\n    }, 30);\n    let recording = false;\n    const shouldRecord = (event) => {\n        return !isUndo(event) && !isRedo(event)\n            && event.key !== 'Meta'\n            && event.key !== 'Control'\n            && event.key !== 'Alt'\n            && !event.key.startsWith('Arrow');\n    };\n    const debounceRecordHistory = debounce((event) => {\n        if (shouldRecord(event)) {\n            recordHistory();\n            recording = false;\n        }\n    }, 300);\n    const on = (type, fn) => {\n        listeners.push([type, fn]);\n        editor.addEventListener(type, fn);\n    };\n    on('keydown', event => {\n        if (event.defaultPrevented)\n            return;\n        prev = toString();\n        if (options.preserveIdent)\n            handleNewLine(event);\n        else\n            legacyNewLineFix(event);\n        if (options.catchTab)\n            handleTabCharacters(event);\n        if (options.addClosing)\n            handleSelfClosingCharacters(event);\n        if (options.history) {\n            handleUndoRedo(event);\n            if (shouldRecord(event) && !recording) {\n                recordHistory();\n                recording = true;\n            }\n        }\n        if (isLegacy)\n            restore(save());\n    });\n    on('keyup', event => {\n        if (event.defaultPrevented)\n            return;\n        if (event.isComposing)\n            return;\n        if (prev !== toString())\n            debounceHighlight();\n        debounceRecordHistory(event);\n        if (callback)\n            callback(toString());\n    });\n    on('focus', _event => {\n        focus = true;\n    });\n    on('blur', _event => {\n        focus = false;\n    });\n    on('paste', event => {\n        recordHistory();\n        handlePaste(event);\n        recordHistory();\n        if (callback)\n            callback(toString());\n    });\n    function save() {\n        const s = getSelection();\n        const pos = { start: 0, end: 0, dir: undefined };\n        let { anchorNode, anchorOffset, focusNode, focusOffset } = s;\n        if (!anchorNode || !focusNode)\n            throw 'error1';\n        // Selection anchor and focus are expected to be text nodes,\n        // so normalize them.\n        if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n            anchorNode = node;\n            anchorOffset = 0;\n        }\n        if (focusNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n            focusNode = node;\n            focusOffset = 0;\n        }\n        visit(editor, el => {\n            if (el === anchorNode && el === focusNode) {\n                pos.start += anchorOffset;\n                pos.end += focusOffset;\n                pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\n                return 'stop';\n            }\n            if (el === anchorNode) {\n                pos.start += anchorOffset;\n                if (!pos.dir) {\n                    pos.dir = '->';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            else if (el === focusNode) {\n                pos.end += focusOffset;\n                if (!pos.dir) {\n                    pos.dir = '<-';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            if (el.nodeType === Node.TEXT_NODE) {\n                if (pos.dir != '->')\n                    pos.start += el.nodeValue.length;\n                if (pos.dir != '<-')\n                    pos.end += el.nodeValue.length;\n            }\n        });\n        // collapse empty text nodes\n        editor.normalize();\n        return pos;\n    }\n    function restore(pos) {\n        const s = getSelection();\n        let startNode, startOffset = 0;\n        let endNode, endOffset = 0;\n        if (!pos.dir)\n            pos.dir = '->';\n        if (pos.start < 0)\n            pos.start = 0;\n        if (pos.end < 0)\n            pos.end = 0;\n        // Flip start and end if the direction reversed\n        if (pos.dir == '<-') {\n            const { start, end } = pos;\n            pos.start = end;\n            pos.end = start;\n        }\n        let current = 0;\n        visit(editor, el => {\n            if (el.nodeType !== Node.TEXT_NODE)\n                return;\n            const len = (el.nodeValue || '').length;\n            if (current + len > pos.start) {\n                if (!startNode) {\n                    startNode = el;\n                    startOffset = pos.start - current;\n                }\n                if (current + len > pos.end) {\n                    endNode = el;\n                    endOffset = pos.end - current;\n                    return 'stop';\n                }\n            }\n            current += len;\n        });\n        if (!startNode)\n            startNode = editor, startOffset = editor.childNodes.length;\n        if (!endNode)\n            endNode = editor, endOffset = editor.childNodes.length;\n        // Flip back the selection\n        if (pos.dir == '<-') {\n            [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n        }\n        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n    }\n    function beforeCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setEnd(r0.startContainer, r0.startOffset);\n        return r.toString();\n    }\n    function afterCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setStart(r0.endContainer, r0.endOffset);\n        return r.toString();\n    }\n    function handleNewLine(event) {\n        if (event.key === 'Enter') {\n            const before = beforeCursor();\n            const after = afterCursor();\n            let [padding] = findPadding(before);\n            let newLinePadding = padding;\n            // If last symbol is \"{\" ident new line\n            // Allow user defines indent rule\n            if (options.indentOn.test(before)) {\n                newLinePadding += options.tab;\n            }\n            // Preserve padding\n            if (newLinePadding.length > 0) {\n                preventDefault(event);\n                event.stopPropagation();\n                insert('\\n' + newLinePadding);\n            }\n            else {\n                legacyNewLineFix(event);\n            }\n            // Place adjacent \"}\" on next line\n            if (newLinePadding !== padding && after[0] === '}') {\n                const pos = save();\n                insert('\\n' + padding);\n                restore(pos);\n            }\n        }\n    }\n    function legacyNewLineFix(event) {\n        // Firefox does not support plaintext-only mode\n        // and puts <div><br></div> on Enter. Let's help.\n        if (isLegacy && event.key === 'Enter') {\n            preventDefault(event);\n            event.stopPropagation();\n            if (afterCursor() == '') {\n                insert('\\n ');\n                const pos = save();\n                pos.start = --pos.end;\n                restore(pos);\n            }\n            else {\n                insert('\\n');\n            }\n        }\n    }\n    function handleSelfClosingCharacters(event) {\n        const open = `([{'\"`;\n        const close = `)]}'\"`;\n        const codeAfter = afterCursor();\n        const codeBefore = beforeCursor();\n        const escapeCharacter = codeBefore.substr(codeBefore.length - 1) === '\\\\';\n        const charAfter = codeAfter.substr(0, 1);\n        if (close.includes(event.key) && !escapeCharacter && charAfter === event.key) {\n            // We already have closing char next to cursor.\n            // Move one char to right.\n            const pos = save();\n            preventDefault(event);\n            pos.start = ++pos.end;\n            restore(pos);\n        }\n        else if (open.includes(event.key)\n            && !escapeCharacter\n            && (`\"'`.includes(event.key) || ['', ' ', '\\n'].includes(charAfter))) {\n            preventDefault(event);\n            const pos = save();\n            const wrapText = pos.start == pos.end ? '' : getSelection().toString();\n            const text = event.key + wrapText + close[open.indexOf(event.key)];\n            insert(text);\n            pos.start++;\n            pos.end++;\n            restore(pos);\n        }\n    }\n    function handleTabCharacters(event) {\n        if (event.key === 'Tab') {\n            preventDefault(event);\n            if (event.shiftKey) {\n                const before = beforeCursor();\n                let [padding, start,] = findPadding(before);\n                if (padding.length > 0) {\n                    const pos = save();\n                    // Remove full length tab or just remaining padding\n                    const len = Math.min(options.tab.length, padding.length);\n                    restore({ start, end: start + len });\n                    document.execCommand('delete');\n                    pos.start -= len;\n                    pos.end -= len;\n                    restore(pos);\n                }\n            }\n            else {\n                insert(options.tab);\n            }\n        }\n    }\n    function handleUndoRedo(event) {\n        if (isUndo(event)) {\n            preventDefault(event);\n            at--;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at < 0)\n                at = 0;\n        }\n        if (isRedo(event)) {\n            preventDefault(event);\n            at++;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at >= history.length)\n                at--;\n        }\n    }\n    function recordHistory() {\n        if (!focus)\n            return;\n        const html = editor.innerHTML;\n        const pos = save();\n        const lastRecord = history[at];\n        if (lastRecord) {\n            if (lastRecord.html === html\n                && lastRecord.pos.start === pos.start\n                && lastRecord.pos.end === pos.end)\n                return;\n        }\n        at++;\n        history[at] = { html, pos };\n        history.splice(at + 1);\n        const maxHistory = 300;\n        if (at > maxHistory) {\n            at = maxHistory;\n            history.splice(0, 1);\n        }\n    }\n    function handlePaste(event) {\n        preventDefault(event);\n        const text = (event.originalEvent || event)\n            .clipboardData\n            .getData('text/plain')\n            .replace(/\\r/g, '');\n        const pos = save();\n        insert(text);\n        highlight(editor);\n        restore({ start: pos.start + text.length, end: pos.start + text.length });\n    }\n    function visit(editor, visitor) {\n        const queue = [];\n        if (editor.firstChild)\n            queue.push(editor.firstChild);\n        let el = queue.pop();\n        while (el) {\n            if (visitor(el) === 'stop')\n                break;\n            if (el.nextSibling)\n                queue.push(el.nextSibling);\n            if (el.firstChild)\n                queue.push(el.firstChild);\n            el = queue.pop();\n        }\n    }\n    function isCtrl(event) {\n        return event.metaKey || event.ctrlKey;\n    }\n    function isUndo(event) {\n        return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ';\n    }\n    function isRedo(event) {\n        return isCtrl(event) && event.shiftKey && event.code === 'KeyZ';\n    }\n    function insert(text) {\n        text = text\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n        document.execCommand('insertHTML', false, text);\n    }\n    function debounce(cb, wait) {\n        let timeout = 0;\n        return (...args) => {\n            clearTimeout(timeout);\n            timeout = window.setTimeout(() => cb(...args), wait);\n        };\n    }\n    function findPadding(text) {\n        // Find beginning of previous line.\n        let i = text.length - 1;\n        while (i >= 0 && text[i] !== '\\n')\n            i--;\n        i++;\n        // Find padding of the line.\n        let j = i;\n        while (j < text.length && /[ \\t]/.test(text[j]))\n            j++;\n        return [text.substring(i, j) || '', i, j];\n    }\n    function toString() {\n        return editor.textContent || '';\n    }\n    function preventDefault(event) {\n        event.preventDefault();\n    }\n    function getSelection() {\n        var _a;\n        if (((_a = editor.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == Node.DOCUMENT_FRAGMENT_NODE) {\n            return editor.parentNode.getSelection();\n        }\n        return window.getSelection();\n    }\n    return {\n        updateOptions(newOptions) {\n            Object.assign(options, newOptions);\n        },\n        updateCode(code) {\n            editor.textContent = code;\n            highlight(editor);\n        },\n        onUpdate(cb) {\n            callback = cb;\n        },\n        toString,\n        save,\n        restore,\n        recordHistory,\n        destroy() {\n            for (let [type, fn] of listeners) {\n                editor.removeEventListener(type, fn);\n            }\n        },\n    };\n}\n"],"names":["globalWindow","window","CodeJar","editor","highlight","opt","options","Object","assign","tab","indentOn","spellcheck","catchTab","preserveIdent","addClosing","history","document","callback","prev","listeners","at","focus","setAttribute","style","outline","overflowWrap","overflowY","whiteSpace","isLegacy","contentEditable","debounceHighlight","debounce","pos","save","restore","recording","shouldRecord","event","isUndo","isRedo","key","startsWith","debounceRecordHistory","recordHistory","on","type","fn","push","addEventListener","s","getSelection","start","end","dir","undefined","anchorNode","anchorOffset","focusNode","focusOffset","nodeType","Node","ELEMENT_NODE","node","createTextNode","insertBefore","childNodes","visit","el","TEXT_NODE","nodeValue","length","normalize","startNode","endNode","startOffset","endOffset","current","len","setBaseAndExtent","beforeCursor","r0","getRangeAt","r","createRange","selectNodeContents","setEnd","startContainer","toString","afterCursor","setStart","endContainer","legacyNewLineFix","preventDefault","stopPropagation","insert","html","innerHTML","lastRecord","splice","visitor","queue","firstChild","pop","nextSibling","isCtrl","metaKey","ctrlKey","shiftKey","code","text","replace","execCommand","cb","wait","timeout","args","clearTimeout","setTimeout","findPadding","i","j","test","substring","textContent","_a","parentNode","DOCUMENT_FRAGMENT_NODE","defaultPrevented","before","after","padding","newLinePadding","handleNewLine","Math","min","handleTabCharacters","open","close","codeAfter","codeBefore","escapeCharacter","substr","charAfter","includes","wrapText","indexOf","handleSelfClosingCharacters","record","handleUndoRedo","isComposing","_event","originalEvent","clipboardData","getData","handlePaste","updateOptions","newOptions","updateCode","onUpdate","destroy","removeEventListener"],"sourceRoot":""}