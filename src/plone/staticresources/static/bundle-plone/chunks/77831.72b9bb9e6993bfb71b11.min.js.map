{"version":3,"file":"chunks/77831.72b9bb9e6993bfb71b11.min.js","mappings":"0NAOIA,EAAM,cAAkB,gBACxBC,EAAuB,QAEvBC,EAAW,WAAY,CACvBC,KAAM,WACNC,QAAS,gBAETC,aACI,GAAIC,KAAKC,IAAIC,GAAGF,KAAKF,SAAU,CAK3B,IAAIK,EAASH,KAAKC,IAAIC,GAAG,UAAYF,KAAKC,IAAIG,MAAQJ,KAAKC,IAAII,cAC1CL,KAAKM,OAAOH,IACxBI,WAAWP,KAAKC,OAIjCF,aAAaM,GACT,MAAMG,SAAkB,uCAAoBC,QAG5CD,EAASE,WAAWC,SAAW,WAC3B,MAAO,CACH,CACIC,KAAM,SACNC,OAAQ,SAAUV,GACd,OAAOA,EAAOW,QAAQ,oBAAoB,SAAUC,EAAOC,GACvD,OAAIA,EACO,uEAEA,6CAQ/B,MAAMC,EAAa,IAAE,UACfC,EAAY,IAAIV,EAASW,UAAU,CACrCC,QAAQ,EACRV,WAAY,CAAC,cAGjB,OADAO,EAAWI,KAAKH,EAAUI,SAASjB,IAC5BY,GAGXlB,yBAAyBwB,EAAKC,GAC1B,IAAIC,EACAtB,EAASqB,EACb,GAAID,EAAIpB,QAAuD,QAA5CsB,EAAS,aAAaC,KAAKH,EAAIpB,SAAmB,CAEjE,GAAe,QADfA,EAASH,KAAK2B,eAAexB,EAAQsB,EAAO,KAGxC,OADA/B,EAAIkC,KAAK,2BAA6BL,EAAIpB,OAAS,QAAUoB,EAAIM,KAC1D,IAAE,UAAUC,KAAK,WAAYP,EAAIM,KAE5C1B,GAAU,KAGd,aADuBH,KAAKM,OAAOH,IACnB2B,KAAK,WAAYP,EAAIpB,OAASoB,EAAIM,IAAMN,EAAIpB,OAASoB,EAAIM,MAG7EF,eAAetB,EAAMoB,GACjB,IAAIM,EAASC,EACbP,EAAS,iBAAmBA,GAC5B,IAAIQ,EAAU,IAAIC,OACV,kDAAkDpB,QAC9C,UACAW,GAEJ,KAEJV,EAAQkB,EAAQP,KAAKrB,GACzB,GAAc,OAAVU,EACA,OAAO,KACJ,GAAIA,EAAM,GAEbiB,EAAQjB,EAAM,GAAGoB,OAGjBJ,GAFAA,EACI,gFACcjB,QAAQ,WAAYkB,OACnC,KAAIjB,EAAM,GAUb,OADArB,EAAI0C,MAAM,kCAAmCrB,GACtC,KAPHgB,EADa,MAAbhB,EAAM,GAEF,qEAGA,wEAWZ,OANAgB,EAAUA,EAAQjB,QAAQ,UAAWW,GAGvB,QADdV,GADAkB,EAAU,IAAIC,OAAOH,EAAS,MACdL,KAAKrB,KAEjBX,EAAI0C,MAAM,qDAEG,OAAVrB,EAAiBA,EAAM,GAAK,QAI3C,IAAEsB,UAAUC,OAAM,WACd,IAAED,SAASE,MAAMC,GACb,yCACA,gBACA,WAIe,IAAExC,MAAMwB,KAAK,cACnBiB,SAAQ,SAAUlB,GACf5B,EAAqB+C,KAAKnB,EAAIM,OAC9BN,EAAIoB,SAAW,qBAOnC,wBAA2B,WAAY,CACnC5C,QAAa,MAAC6C,EAAMpB,UACHqB,QAAQC,IACjBF,EAAKG,KAAIhD,eAAgBwB,GACrB,IAAIyB,EAAMpD,EAASqD,KAAK1B,EAAI2B,SAE5B,aADuBF,EAAIG,mBAAmB5B,EAAKC,SAOnE","sources":["webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["import \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["log","is_markdown_resource","Markdown","name","trigger","async","this","$el","is","source","val","text","render","replaceAll","Showdown","default","extensions","prettify","type","filter","replace","match","pre","$rendering","converter","Converter","tables","html","makeHtml","cfg","data","header","exec","extractSection","warn","url","attr","pattern","level","matcher","RegExp","length","error","document","ready","body","on","forEach","test","dataType","cfgs","Promise","all","map","pat","init","$target","renderForInjection"],"sourceRoot":""}